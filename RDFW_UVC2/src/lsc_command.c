// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file lsc_command.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/

#include <stdio.h>
#include "lsc_usb_dev.h"

//#define DEBUG_LSC_CMD

#ifdef DEBUG_LSC_CMD
#define LSC_CMD(msg, ...) sprintf(print_buf, msg, ##__VA_ARGS__); lsc_uart_tx(print_buf)
#else
#define LSC_CMD(msg, ...)
#endif

extern struct lsc_usb_dev_dm usb_dev_dm __attribute__((section(".myBufSection")));

/****************************************************************************/
/**
 * Returns zeroed parameters to be used by Endpoint commands
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   Zeroed Params structure pointer.
 *
 * @note     None.
 *****************************************************************************/
struct lsc_ep_params* lsc_usb_get_ep_params (struct lsc_usb_dev *usb_dev)
{
    LSC_CMD("lsc_usb_get_ep_params\r\n");

// Setting ep_params to zero.
    usb_dev->ep_params.param0 = 0x00;
    usb_dev->ep_params.param1 = 0x00;
    usb_dev->ep_params.param2 = 0x00;

    return &usb_dev->ep_params;

}

/****************************************************************************/
/**
 * This function sends physical endpoint-specific commands.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    dir is direction of endpoint
 *           - LSC_EP_DIR_IN/ LSC_EP_DIR_OUT.
 * @param    cmd is Endpoint command.
 * @param    params is Endpoint command parameters.
 *
 * @return   LSC_SUCCESS if the command was sent successfully, else LSC_FAIL.
 *
 * @note     Refer sec 3.2.2 of Synopsis Programming Guide Version 3.30b
 *           for detailed information about various physical endpoint-specific
 *           commands.
 *****************************************************************************/
uint32_t lsc_usb_send_ep_cmd (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir, uint32_t cmd, struct lsc_ep_params *params)
{
    LSC_CMD("lsc_usb_send_ep_cmd\r\n");

    uint32_t phy_ep_num, saved_config = 0, reg = 0;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);

    // When operating at USB 2.0 speeds (HS/FS), if either GUSB2PHYCFG.ENBLSLPM or
    // GUSB2PHYCFG.SUSPHY is set, it must be cleared before issuing an endpoint command.
    //
    // Save and clear both GUSB2PHYCFG.ENBLSLPM and GUSB2PHYCFG.SUSPHY settings.
    // Restore them after the command is completed.
    // Refer https://elixir.bootlin.com/linux/v6.6.7/source/drivers/usb/dwc3/gadget.c#L304

    if ((usb_dev->dev_speed < LSC_DCFG_SUPERSPEED)
            || (LSC_DEPCMD_CMD(cmd) == LSC_DEPCMD_ENDTRANSFER)) {

        // Read the USB2PHYCFG register
        reg = lsc_32_read(usb_dev->base_add + LSC_GUSB2PHYCFG(0));

        // Check for SUSPHY bit
        if ((reg & LSC_GUSB2PHYCFG_SUSPHY)) {
            saved_config |= LSC_GUSB2PHYCFG_SUSPHY;
            reg &= ~LSC_GUSB2PHYCFG_SUSPHY;
        }

        // Check for ENBLSLPM bit
        if (reg & LSC_GUSB2PHYCFG_ENBLSLPM) {
            saved_config |= LSC_GUSB2PHYCFG_ENBLSLPM;
            reg &= ~LSC_GUSB2PHYCFG_ENBLSLPM;
        }

        // Write back the register if any bit was cleared
        if (saved_config)
            lsc_32_write((usb_dev->base_add + LSC_GUSB2PHYCFG(0)), reg);
    }

    /*
     * For some commands such as Update Transfer command, DEPCMDPARn
     * registers are reserved. Since the driver often sends Update Transfer
     * command, don't write to DEPCMDPARn to avoid register write delays and
     * improve performance.
     */
    if (LSC_DEPCMD_CMD(cmd) != LSC_DEPCMD_UPDATETRANSFER) {

        lsc_32_write((usb_dev->base_add + LSC_DEPCMDPAR0(phy_ep_num)),
                params->param0);
        lsc_32_write((usb_dev->base_add + LSC_DEPCMDPAR1(phy_ep_num)),
                params->param1);
        lsc_32_write((usb_dev->base_add + LSC_DEPCMDPAR2(phy_ep_num)),
                params->param2);

    }

    if ((LSC_DEPCMD_CMD(cmd) == LSC_DEPCMD_UPDATETRANSFER) /* && (ep-> != LSC_ENDPOINT_XFER_ISOC) FIX_ME*/)
    {
        cmd &= ~(LSC_DEPCMD_CMDIOC | LSC_DEPCMD_CMDACT);
    } else {
        cmd |= LSC_DEPCMD_CMDACT;
    }

    lsc_32_write((usb_dev->base_add + LSC_DEPCMD(phy_ep_num)), cmd);

    // Poll CMDACT
    while (lsc_32_read(usb_dev->base_add + LSC_DEPCMD(phy_ep_num))
            & LSC_DEPCMD_CMDACT)
        ;

    // Restore the saved configuration
    if (saved_config) {
        reg = lsc_32_read(usb_dev->base_add + LSC_GUSB2PHYCFG(0));
        reg |= saved_config;
        lsc_32_write((usb_dev->base_add + LSC_GUSB2PHYCFG(0)), reg);
    }

    reg = lsc_32_read(usb_dev->base_add + LSC_DEPCMD(phy_ep_num));

    //Extracts the command status
    reg = LSC_DEPCMD_STATUS(reg);

    // Check the command status
    if (reg != 0) {
        LSC_CMD("cmd_status_failed 0x%x\r\n",reg);
        return LSC_FAIL;
    }

    return LSC_SUCCESS;
}

/**
 * This function sends generic commands.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    cmd is the command to be sent.
 * @param    param is the parameter for the command.
 *
 * @return   LSC_SUCCESS if the command was sent successfully, else LSC_FAIL.
 */
uint32_t lsc_usb_send_generic_cmd (struct lsc_usb_dev *usb_dev, uint32_t cmd,
        uint32_t param)
{
    LSC_CMD("lsc_usb_send_generic_cmd\r\n");

    uint32_t reg_val = 0;

    lsc_32_write((usb_dev->base_add + LSC_DGCMDPAR), param);

    lsc_32_write((usb_dev->base_add + LSC_DGCMD), (cmd | LSC_DGCMD_CMDACT));

    // Poll CMDACT
    while (lsc_32_read(usb_dev->base_add + LSC_DGCMD) & LSC_DGCMD_CMDACT)
        ;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DGCMD);

    //Extracts the command status
    reg_val = LSC_DGCMD_STATUS(reg_val);

    // Check the status of the command
    if ( reg_val != 0) {
        LSC_CMD("DGCMD_status_failed 0x%x\r\n",reg_val);
        return LSC_FAIL;
    }

    return LSC_SUCCESS;
}

/****************************************************************************/
/**
 * @brief
 * Enables Endpoint for sending/receiving data. Endpoints are
 * enabled using Start New Configuration (DEPSTARTCFG) and
 * Set Endpoint Configuration (DEPCFG)
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    dir is direction of endpoint
 *               - LSC_EP_DIR_IN/ LSC_EP_DIR_OUT.
 * @param    max_size is size of Endpoint size.
 * @param    ep_type is Endpoint type Control/Bulk/Interrupt/Isoc.
 * @param    restore should be true if saved state should be restored;
 *           typically this would be false
 *
 * @return   LSC_SUCCESS else LSC_FAIL
 *
 * @note     Refer sec 3.2.2 of Synopsis Programming Guide Version 3.30b
 *           for Physical Endpoint-Specific Command Structure.
 ****************************************************************************/
uint32_t lsc_usb_ep_enable (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir, uint16_t max_size, uint8_t ep_type, uint8_t restore)
{
    LSC_CMD("lsc_usb_ep_enable\r\n");

    LSC_CMD("usb_ep_num: %x\tdir: %x\tmax_size: %x\tep_type: %x\r\n", usb_ep_num, dir, max_size, ep_type);

    struct lsc_ep *ep;
    uint32_t reg_val;
    uint32_t phy_ep_num;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);
    ep = &usb_dev->eps[phy_ep_num];

    LSC_CMD("phy_ep_num: %x\tep->ep_status: %x\r\n", phy_ep_num, ep->ep_status);

    ep->usb_ep_num = usb_ep_num;
    ep->ep_direction = dir;
    ep->ep_type = ep_type;
    ep->max_ep_size = max_size;
    ep->phy_ep_num = phy_ep_num;
    ep->cur_micro_frame = 0;

    if ((ep->ep_status & LSC_EP_ENABLED) == 0) {

        if (lsc_usb_start_ep_cfg(usb_dev, usb_ep_num, dir) == LSC_FAIL) {

            return LSC_FAIL;
        }
    }

    if (lsc_usb_set_ep_cfg(usb_dev, usb_ep_num, dir, max_size, ep_type, restore)
            == LSC_FAIL) {

        return LSC_FAIL;
    }

    if ((ep->ep_status & LSC_EP_ENABLED) == 0) {

        if (lsc_usb_set_xfer_resource(usb_dev, usb_ep_num, dir) == LSC_FAIL) {

            return LSC_FAIL;
        }

        ep->ep_status |= LSC_EP_ENABLED;

        reg_val = lsc_32_read(usb_dev->base_add + LSC_DALEPENA);
        reg_val |= (LSC_DALEPENA_EP(ep->phy_ep_num));

        lsc_32_write((usb_dev->base_add + LSC_DALEPENA), reg_val);
        LSC_CMD("Active EP: %x\r\n",
                lsc_32_read(usb_dev->base_add + LSC_DALEPENA));
    }

#ifdef LINK_TRB_USE

    struct lsc_trb *trb = NULL, *TrbTempNext = NULL;

    /* Link TRB. The HWO bit is never reset */
//    trb = &ep->ep_trb[0];
    trb = &usb_dev_dm.ep_trb[phy_ep_num][0];

//    TrbTempNext = &ep->ep_trb[NO_OF_TRB_PER_EP]; // last trb use for link trb
    TrbTempNext = &usb_dev_dm.ep_trb[phy_ep_num][NO_OF_TRB_PER_EP]; // last trb use for link trb
    TrbTempNext->buf_ptr_lo = (uintptr_t)trb;
    TrbTempNext->buf_ptr_hi = ((uintptr_t)trb >> 16) >> 16;
    TrbTempNext->size = 0;
    TrbTempNext->ctrl = LSC_TRB_CTRL_HWO | LSC_TRBCTL_LINK_TRB;

    LSC_CMD("LAST TRB register as Link TRB for Active EP: %x\r\n",lsc_32_read(usb_dev->base_add + LSC_DALEPENA));

#endif

    return LSC_SUCCESS;
}

/****************************************************************************/
/**
 * @brief
 * Disables Endpoint. It clears corresponding bit for a physical
 * endpoint from Device Active USB Endpoint Enable Register (DALEPENA).
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    dir is direction of endpoint
 *           - LSC_EP_DIR_IN/ LSC_EP_DIR_OUT.
 *
 * @return   LSC_SUCCESS else LSC_FAIL
 *
 * @note     Refer sec 1.3.7 of Synopsis Programming Guide Version 3.30b
 *           for Device Active USB Endpoint Enable Register (DALEPENA).
 ****************************************************************************/
uint32_t lsc_usb_ep_disable (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir)
{
    LSC_CMD("lsc_usb_ep_disable\r\n");

    uint32_t reg_val;
    uint8_t phy_ep_num;
    struct lsc_ep *ep;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);
    ep = &usb_dev->eps[phy_ep_num];

    /* make sure HW endpoint isn't stalled */
    if ((ep->ep_status & LSC_EP_STALL) != 0) {
        lsc_usb_ep_clear_stall(usb_dev, ep->usb_ep_num, ep->ep_direction);
    }

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DALEPENA);
    reg_val &= ~LSC_DALEPENA_EP(ep->phy_ep_num);

    lsc_32_write((usb_dev->base_add + LSC_DALEPENA), reg_val);

    ep->ep_type = 0;
    ep->ep_status = 0;
    ep->max_ep_size = 0;
    ep->trb_enqueue = 0;
    ep->trb_dequeue = 0;
    ep->maxburst = 0;
    ep->requested_bytes = 0;
    ep->remain_bytes = 0;
    ep->bytes_txfered = 0;
    ep->buffer_ptr = NULL;
    ep->ep_buf_i_enqueue = 0;
    ep->ep_buf_i_rd = 0;
    ep->ep_buf_i_dequeue = 0;

    /* struct lsc_ep_buf_info lsc_ep_buf_i[MAX] clearing */
    memset(ep->ep_buf_i, 0, sizeof(struct lsc_ep_buf_info) * NO_OF_BUF);

    /* struct lsc_trb ep_trb[NO_OF_TRB_PER_EP + 1] clearing */
//    memset(ep->ep_trb, 0, sizeof(struct lsc_trb) * (NO_OF_TRB_PER_EP + 1));
    memset(&(usb_dev_dm.ep_trb[phy_ep_num][0]), 0, sizeof(struct lsc_trb) * (NO_OF_TRB_PER_EP + 1));

    return LSC_SUCCESS;
}

/** @} */
