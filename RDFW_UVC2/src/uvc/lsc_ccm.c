// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPEL™
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file lsc_ccm.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/

#include <stdio.h>
#include "uart.h"
#include "utils.h"
#include "camera_initialization.h"
#include "lsc_ccm_reg.h"


uint8_t lsc_ccm_init(uint32_t base_addr)
{

    uint8_t i;

    signed char ccm_coeff_buf[9] = {
    		MRR_VALUE, MRG_VALUE, MRB_VALUE,
			MGR_VALUE, MGG_VALUE, MGB_VALUE,
			MBR_VALUE, MBG_VALUE, MBB_VALUE
    };

    int16_t ccm_translation_buf[3] = {
    		TRANSLATION_R_VALUE, TRANSLATION_G_VALUE, TRANSLATION_B_VALUE
    };



	 // CMM enable
	 // 0x1 – enable( Color Correction Matrix operation)
	 // 0x0 – disable(the output pixel data is the same as the input data)
     //IMP Note: CCM UG has incorrect value for enable/disable.
//     printf ("CCM register CCM_CONTROL 0x%x \r\n", lsc_32_read (base_addr + CCM_CONTROL) );
	 lsc_32_write((base_addr + CCM_CONTROL), CCM_ENABLE);

	 lsc_32_write((base_addr + CONFIGURATION_UPDATE), 0x0);
	 // MRR
//	 printf ("MRR Macro 0x%x \r\n", GET_CCM_COEFF_INT(ccm_coeff_buf[0]) );
//	 lsc_32_write((base_addr + MRR), GET_CCM_COEFF_INT(ccm_coeff_buf[0]));

	 //Update nine matrix coefficients MRR to MBB
	 for(i=0;i<9;i++)
	 {
		 lsc_32_write((base_addr + (MRR + i*4)), GET_CCM_COEFF_INT(ccm_coeff_buf[i]));
		 printf ("CCM Ceff Addr=0x%x  Value=0x%x\r\n",  (MRR + i*4), lsc_32_read (base_addr + (MRR + i*4)) );
	 }

	 //Update TRANSLATION register for R,G & B
	 for(i=0;i<3;i++)
	 {
		 lsc_32_write((base_addr + (TRANSLATION_R + i*4)), ccm_translation_buf[i]);
		 printf ("CCM TRANSLATION Addr=0x%x  Value=0x%x\r\n",  (TRANSLATION_R + i*4), lsc_32_read (base_addr + (TRANSLATION_R + i*4)) );
	 }

	 //The user must make config_update as 1 after updating all the other registers.
	 //The IP clears this register after reading configuration values.
	 //If the user updates the configuration registers in middle of an active frame,
	 //the updated values will be read in during blanking period for the next frame.
	 lsc_32_write((base_addr + CONFIGURATION_UPDATE), 0x1);


	 printf ("CCM register CCM_CONTROL 0x%x \r\n", lsc_32_read (base_addr + CCM_CONTROL) );
//	 printf ("CCM register CONFIGURATION_UPDATE 0x%x \r\n", lsc_32_read (base_addr + CONFIGURATION_UPDATE) );


	return 0;
}

/** @} */