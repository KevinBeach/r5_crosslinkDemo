// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file lsc_uvc.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *****************************************************************************/


#include <stdio.h>
#include "lsc_usb_dev.h"
#include "lsc_usb_ch9.h"
#include "lsc_uvc.h"
#include "../lsc_in_ep_buf_mgmt.h"
#include "i2c_master.h"
#include "i2c_master_regs.h"
#include "uvc/camera_initialization.h"

extern struct i2cm_instance i2c_master_core;

uint8_t data[64]__attribute__((aligned(4))) , terminalErrorCode[2], var __attribute__((aligned(4))) = 0/*, straming_en = 0*/;
volatile uint8_t straming_en, i2c_stat = 0;
volatile uint32_t bmCtrlsSupported[NO_OF_TERMINALS];
uint32_t temp, selectProcUnitCtrlsArrayCol = 0, selectProcUnitCtrlsArrayRow = 0, selectExtenUnitCtrlsArrayCol = 0, selectExtenUnitCtrlsArrayRow = 0;
volatile uint16_t procUnitCtrlsVal[NO_PROC_UNIT_CONTROLS_SUPPORTED][6], ExtenUnitCtrlsVal[NO_OF_EXTENSION_UNIT_CONTROLS_SUPPORTED][6];

VIDEO_PROBE_AND_COMMIT_CONTROL vdoProbeCommit, TempVdoProbeCommit;
VIDEO_STILL_IMG_PROBECOMMIT_CONTROL vdoStillImgProbeComit, TempStillImgVdoProbeCommit;
FORMAT_OF_PAYLOAD_HEADER vdoFormatPayloadHeader;

//uint8_t i2c_rx_bufr[256] __attribute__((aligned(4))) = { 0 };
uint16_t i2c_tx_len = 0;

uint8_t i2c_tx_bufr[64] __attribute__((aligned(8)))/*__attribute__((section(".myBufSection")))*/ = { 0 };
//extern uint8_t res_buf[256] __attribute__ ((aligned(8)))__attribute__((section(".myBufSection")));
uint16_t i2c_rx_len = 0;

void lsc_usb_class_req(struct lsc_usb_dev *dev, setup_pkt *setup_pkt)
{
    struct lsc_usb_dev *usb_dev;
    usb_dev = (struct lsc_usb_dev*)dev;
    uint32_t resp_len = 0, data_size = 0, err = 0;

    printf("Setup Pkt: %x %x %2x %2x %2x\r\n", setup_pkt->bRequestType,
            setup_pkt->bRequest, setup_pkt->wValue, setup_pkt->wIndex,
            setup_pkt->wLength);

    /*
     * Direction -- USB_EP_DIR_IN or USB_EP_DIR_OUT
     */
    uint8_t dir = !!(setup_pkt->bRequestType & LSC_USB_DIR_IN);

    if ((setup_pkt->bRequestType & USB_RECIPIENT_MASK) == USB_RECIPIENT_INTERFACE)
    {
        if(((setup_pkt->wIndex & 0xFF) == 0) && (((setup_pkt->wIndex >> 8) & 0xFF) == 0))
        {
            /***
            * This means that request came for video control interface
            * not to some unit/terminal in video control interface
            ***/

            printf("VC_0_0\r\n");

            temp = (setup_pkt->wValue>> 8) & 0xFF;

            switch (setup_pkt->bRequest)
            {
                case GET_CUR:

                    switch (temp)
                    {
                        case VC_REQUEST_ERROR_CODE_CONTROL:

                            var = terminalErrorCode[VC_ERR_CODE_INDEX];
                            data_size = 1;
                            err = 0;

                            break;

                        case VC_VIDEO_POWER_MODE_CONTROL:

                            err = 1;

                            break;
                    }

                    break;

                case GET_INFO:

                    switch (temp)
                    {
                        case VC_REQUEST_ERROR_CODE_CONTROL:
                            var = 0x01; //(unsigned char*)terminalErrorCode[VC_ERR_CODE_INDEX];
                            data_size = 1;

                            break;

                        case VC_VIDEO_POWER_MODE_CONTROL:

                            err = 1;

                            break;
                    }

                    break;

                default:

                    var = ERR_CODE_NO_ERR;
                    data_size = 1;

                    err = 1;

                    break;
            }
            if (!err)
            {
                lsc_usb_ep0_send(usb_dev, (uint8_t*)&var, data_size);
            } else

            {
                terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_CTRL;

                lsc_usb_ep0_stall_restart(usb_dev);

                return;
            }
        }
        else if (((setup_pkt->wIndex & 0xFF) == 0) && (((setup_pkt->wIndex >> 8) & 0xFF) != 0))
        {
            /***
             * This means that request came for Unit/Terminal in video control interface
             ***/

            printf("VC_0_1\r\n");

            if (((setup_pkt->wIndex >> 8) & 0xFF) == RECEPIENT_IS_PROCESSING_UNIT)
            {
                printf("Processing Unit Req\r\n");

                selectProcUnitCtrlsArrayRow = ((setup_pkt->wValue >> 8) & 0xFF);

                if (!(bmCtrlsSupported[PU_BMCONTROLS_INDEX] & selectProcUnitCtrlsArrayRow))
                {
                    //if control not supported and request came for that Control Selector
                    //then HALT the control endpoint and sets the error code

                    printf(" PU Control not supported\r\n");

//                    printf(" PU Control not supported\r\n");

                    terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_CTRL;

                    lsc_usb_ep0_stall_restart(usb_dev);

                    return;
                }

                data_size = 0x02;

                switch (setup_pkt->bRequest)
                {
                    case GET_CUR:
                        selectProcUnitCtrlsArrayCol = GET_CUR_VAL_INDEX;
                        break;
                    case GET_DEF:
                        selectProcUnitCtrlsArrayCol = GET_DEF_VAL_INDEX;
                        break;
                    case GET_INFO:
                        data_size = 0x01;
                        selectProcUnitCtrlsArrayCol = GET_INFO_VAL_INDEX;
                        break;
                    case GET_LEN:
                        selectProcUnitCtrlsArrayCol = -1;
                        break;
                    case GET_MAX:
                        selectProcUnitCtrlsArrayCol = GET_MAX_VAL_INDEX;
                        break;
                    case GET_MIN:
                        selectProcUnitCtrlsArrayCol = GET_MIN_VAL_INDEX;
                        break;
                    case GET_RES:
                        selectProcUnitCtrlsArrayCol = GET_RES_VAL_INDEX;
                        break;

                    default:
                        printf(" Set PU\r\n");

                        terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_REQ;

                        lsc_usb_ep0_stall_restart(usb_dev);

                        return;
                }

                temp = (setup_pkt->wValue >> 8) & 0xFF;

                var = procUnitCtrlsVal[selectProcUnitCtrlsArrayRow][selectProcUnitCtrlsArrayCol];

                lsc_usb_ep0_send(usb_dev, (uint8_t*)&var, data_size);

            }
            else if (((setup_pkt->wIndex >> 8) & 0xFF) == RECEPIENT_IS_EXTENSION_UNIT)
            {
                printf(" Extension Unit req\r\n");

                selectExtenUnitCtrlsArrayRow = (setup_pkt->wValue >> 8) & 0xFF;;

                if (!(bmCtrlsSupported[EU_BMCONTROLS_INDEX] & selectExtenUnitCtrlsArrayRow))
                {
                    //if control not supported and request came for that Control Selector
                    //then HALT the control endpoint and sets the error code

                    printf("XU Control not supported\r\n");

                    terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_CTRL;

                    lsc_usb_ep0_stall_restart(usb_dev);

                    return;
                }

                if(!dir)
                {
                    //Means Host will Send Data
                    switch (usb_dev->ep0_state)
                    {
                        case LSC_EP0_SETUP_PHASE:
    //                        printf("setup\r\n");

                            if (setup_pkt->bRequest == SET_CUR)
                            {
                                printf(" Set EU\r\n");

                                lsc_usb_ep0_rcv(usb_dev, /*i2c_tx_bufr*/res_buf, setup_pkt->wLength);
                            }

                            break;

                        case LSC_EP0_DATA_PHASE:
    //                        printf("data\r\n");

                            i2c_tx_len = setup_pkt->wLength;

                          printf("i2c_tx_len:%x\r\n",i2c_tx_len);
//                          printf("Count:%x\r\n",i2c_tx_bufr[0]);

                          memcpy(i2c_tx_bufr, res_buf,i2c_tx_len);

//                           for(uint32_t k = 0; k<20; k++)
//                                printf("data: %x \r\n", i2c_tx_bufr[k]);

                            //If request is for I2C write only
                            if(i2c_tx_bufr[1] == 0)
                            {
//                                pI2cDev->slv_addr = 0x36;
    //                          i2c_rx_len = 0x3;//To read chip chip of camera sensor
    //                          rcvd_set_xu_data=1;
                                for(uint32_t i=0; i<i2c_tx_bufr[0]; i++)
                                {
                                    printf("Add:%x\r\n", ((i2c_tx_bufr[(i * 4) + 8] << 8)| (i2c_tx_bufr[(i * 4) + 9] /*<< 8*/)));
                                    printf("Val:%x\r\n", (i2c_tx_bufr[(i * 4) + 10] | (i2c_tx_bufr[(i * 4) + 11] << 8)));

//                                    pI2cDev->i2c_op_ongoing = 1;

                                    i2c_stat = i2c_master_write (&i2c_master_core,
                                                      TRGT_SLV_ADDR,
                                                      0x3,  // Every time fix 2 byte of offset address
                                                      &i2c_tx_bufr[(i * 4) + 8] // Tx length
                                                      );
                                    if(!i2c_stat)
                                        printf("I2C Wr success\r\n");
                                    else
                                        printf("I2C Wr fail\r\n");


//                                    if (pI2cDev->i2c_xfer_sts
//                                            == SUCCESS) {
//                                        printf( "I2C Wr Operation was successful.\r\n");
//                                    } else {
//                                        printf(
//                                                "I2C Wr Operation failed. I2C Transfer Status: 0x%x\r\n",
//                                                pI2cDev->i2c_xfer_sts);
//                                         USB30_SetStallEP((void*)usb30dev, 0x80);
//                                    }
                                }
    //                            no_of_bytes_successfully_written =
    //                                    i2c_tx_len
    //                                            - pI2cDev->not_transmitted_bytes;
    //                            no_of_bytes_successfully_read =
    //                                    i2c_rx_len
    //                                            - pI2cDev->not_received_bytes;
    //                            printf("No of bytes successfully written = 0x%x \r\n",
    //                                    no_of_bytes_successfully_written);
    //                            printf("No of bytes successfully read = 0x%x \r\n",
    //                                    no_of_bytes_successfully_read);
                            }

                            break;

                        default:
                            break;
                    }
                }
                else
                {
                    //Means Device will send Data

                    data_size = 0x02;

                    switch (setup_pkt->bRequest)
                    {
                        case GET_CUR:
                            selectExtenUnitCtrlsArrayCol = GET_CUR_VAL_INDEX;
                            {
                                printf("XU:GET_CUR\r\n");

//                                pI2cDev->slv_addr = 0x36;

                                for(uint32_t i=0; i<i2c_tx_bufr[0]; i++)
                                {
                                    printf("Add:%x\r\n", ((i2c_tx_bufr[(i * 4) + 8] << 8) | (i2c_tx_bufr[(i * 4) + 9] /*<< 8*/)));

//                                    pI2cDev->i2c_op_ongoing = 1;

                                    i2c_stat = i2c_master_repeated_start (
                                            &i2c_master_core,
                                            TRGT_SLV_ADDR,
                                            0x2,
                                            &i2c_tx_bufr[(i * 4) + 8],
                                            0x01,
                                            &i2c_tx_bufr[(i * 4) + 10]);

                                    if(!i2c_stat)
                                        printf("I2C Rd success\r\n");
                                    else
                                        printf("I2C Rd fail\r\n");

//                                    if (pI2cDev->i2c_xfer_sts
//                                            == SUCCESS) {
                                        printf( "I2C Rd Operation was successful.: %x\r\n", i2c_tx_bufr[(i * 4) + 10]/*, i2c_tx_bufr[(i * 4) + 11], i2c_tx_bufr[(i * 4) + 12]*/);

//
//    //                                    PCtrlEpReqStatus->PDataStageData = &i2c_rx_bufr[(i * 2)];
//    //                                     //printf("CS: %x\r\n", *PCtrlEpReqStatus->PDataStageData);
//    //                                     PCtrlEpReqStatus->sizeOfDataStageData = (2 * i2c_tx_bufr[0]);
//
//                                    } else {
//                                        printf(
//                                                "I2C Rd Operation failed. I2C Transfer Status: 0x%x\r\n",
//                                                pI2cDev->i2c_xfer_sts);
//                                         USB30_SetStallEP((void*)usb30dev, 0x80);
//                                    }
                                }
//                                PCtrlEpReqStatus->PDataStageData = &i2c_tx_bufr[0];

    //                            for(uint32_t i=0; i<((4 * i2c_tx_bufr[0]) + 8); i++)
    //                                printf("%x  ", *(PCtrlEpReqStatus->PDataStageData +i));
    //
    //                            printf("\r\n");
                                 //printf("CS: %x\r\n", *PCtrlEpReqStatus->PDataStageData);

//                                PCtrlEpReqStatus->sizeOfDataStageData = (4 * i2c_tx_bufr[0]) + 8;

                                lsc_usb_ep0_send(usb_dev, &i2c_tx_bufr[0], ((4 * i2c_tx_bufr[0]) + 8));
                            }
                            break;
                        case GET_DEF:
                            selectExtenUnitCtrlsArrayCol = GET_DEF_VAL_INDEX;
                            lsc_usb_ep0_send(usb_dev, &var, data_size);

                            break;
                        case GET_INFO:
                            data_size = 0x01;
                            var = 0x3;
//                            selectExtenUnitCtrlsArrayCol = GET_INFO_VAL_INDEX;
                            lsc_usb_ep0_send(usb_dev, &var, data_size);

                            break;
                        case GET_LEN:
                            printf("Get XU Len\r\n");
                            var = 0x58;
//                            printf("var: %x\r\n", var);
//                            selectExtenUnitCtrlsArrayCol = -1;
                            lsc_usb_ep0_send(usb_dev, &var, data_size);

                            break;
                        case GET_MAX:
                            selectExtenUnitCtrlsArrayCol = GET_MAX_VAL_INDEX;
                            lsc_usb_ep0_send(usb_dev, &var, data_size);
                            break;
                        case GET_MIN:
                            selectExtenUnitCtrlsArrayCol = GET_MIN_VAL_INDEX;
                            lsc_usb_ep0_send(usb_dev, &var, data_size);
                            break;
                        case GET_RES:
                            selectExtenUnitCtrlsArrayCol = GET_RES_VAL_INDEX;
                            lsc_usb_ep0_send(usb_dev, &var, data_size);
                            break;

                        default:

                            printf(" Set default EU\r\n");

                            terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_REQ;

                            lsc_usb_ep0_stall_restart(usb_dev);

                            break;
                    }

//                    temp = (setup_pkt->wValue >> 8) & 0xFF;
//
//                    var = ExtenUnitCtrlsVal[selectExtenUnitCtrlsArrayRow][selectExtenUnitCtrlsArrayCol];
//
//                    lsc_usb_ep0_send(usb_dev, (uint8_t*)&var, data_size);
                }

            } else if (((setup_pkt->wIndex >> 8) & 0xFF) == RECEPIENT_IS_OUTPUT_TERMINAL)
            {
                printf(" O/P_Term req\r\n");

                terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_REQ;

                lsc_usb_ep0_stall_restart(usb_dev);

                return;

            } else if (((setup_pkt->wIndex >> 8) & 0xFF) == RECEPIENT_IS_CAMERA_TERMINAL)
            {
                printf("\n Camera_Term Req");

                terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_CTRL;

                lsc_usb_ep0_stall_restart(usb_dev);

                return;

            } else
            {
                printf("\n Vc Recepient !supported Req");

                lsc_usb_ep0_stall_restart(usb_dev);

                terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_UNIT;

                return;

            }
        }
        else if (((setup_pkt->wIndex & 0xFF) == 1) && (((setup_pkt->wIndex >> 8) & 0xFF) == 0))
        {
            /***
             * This means that request came for video streaming interface 1 alternate setting 0
             **/

            printf("VS_1_0\r\n");

            if(dir == 1) // Device to Host
            {
//                printf("Get Req\r\n");

                switch ((setup_pkt->wValue >> 8) & 0xFF)
                {
                    case VS_PROBE_CONTROL:

                        printf("Get - PRB_CTRL\r\n");

                        resp_len = setup_pkt->wLength > sizeof(VIDEO_PROBE_AND_COMMIT_CONTROL) ? sizeof(VIDEO_PROBE_AND_COMMIT_CONTROL) : setup_pkt->wLength;

                        lsc_usb_ep0_send(usb_dev, (uint8_t*)&vdoProbeCommit, sizeof(VIDEO_PROBE_AND_COMMIT_CONTROL));

                        break;

                    case VS_STILL_PROBE_CONTROL:

                        printf("Still Probe\r\n");

                        resp_len = setup_pkt->wLength > sizeof(VIDEO_STILL_IMG_PROBECOMMIT_CONTROL) ? sizeof(VIDEO_STILL_IMG_PROBECOMMIT_CONTROL) : setup_pkt->wLength;

                        lsc_usb_ep0_send(usb_dev, (uint8_t*)&vdoStillImgProbeComit, sizeof(VIDEO_STILL_IMG_PROBECOMMIT_CONTROL));

                        break;

                    case VS_COMMIT_CONTROL:

                        printf("Get: Commit Control\r\n");

                        lsc_usb_ep0_send(usb_dev, (uint8_t*)&vdoStillImgProbeComit, setup_pkt->wLength);

                        break;

                    case VS_STILL_COMMIT_CONTROL:

                        printf("Still Commit Control\r\n");

                        break;

                    default:

                        printf("Unsupported Control Selector\r\n");

                        terminalErrorCode[VC_ERR_CODE_INDEX] = -1; ///ERR_CODE_INVALID_CTRL;

                        lsc_usb_ep0_stall_restart(usb_dev);

                        return;
                }
            }
            else if(dir == 0x0) // Host to Device
            {
//                printf("Set Req\r\n");

                switch (usb_dev->ep0_state)
                {
                    case LSC_EP0_SETUP_PHASE:
//                        printf("setup\r\n");
                        lsc_usb_ep0_rcv(usb_dev, /*data*/res_buf, setup_pkt->wLength);

                        break;

                    case LSC_EP0_DATA_PHASE:
//                        printf("data\r\n");
                        switch ((setup_pkt->wValue >> 8) & 0xFF)
                        {
                            case VS_PROBE_CONTROL:

                                printf("Set - PRB_CTRL\r\n");

                                memcpy(&vdoProbeCommit, /*data*/res_buf, setup_pkt->wLength);

//                                for(uint32_t i = 0; i < setup_pkt->wLength; i++)
//                                  printf("%x ", data[i]);
//
//                                printf("\r\n");

#if UVC_ISO
                            vdoProbeCommit.dwMaxPayloadTransferSize = (ISO_TRANSFER_SZ); // ((WIDTH*HEIGHT*BITSPERPIXEL)/8) + 2;                //0x96002;
#ifdef UVC_YUY2
                            vdoProbeCommit.dwMaxVideoFrameSize = ((WIDTH*HEIGHT*BITSPERPIXEL)/8) + 2;
#else
                            ////0x003F4800 static value was there in MJPEG HAL as in that with this equation not getting expected results.
                            vdoProbeCommit.dwMaxVideoFrameSize = 0x003F4800;
#endif
#else
                            vdoProbeCommit.dwMaxPayloadTransferSize = ((WIDTH
                                    * HEIGHT * BITSPERPIXEL) / 8) + 2;
#ifdef UVC_YUY2
                            vdoProbeCommit.dwMaxVideoFrameSize = ((WIDTH
                                    * HEIGHT * BITSPERPIXEL) / 8) + 2;
#else
                            ////0x003F4800 static value was there in MJPEG HAL as in that with this equation not getting expected results.
                          vdoProbeCommit.dwMaxVideoFrameSize = 0x003F4800;
#endif
#endif

                                break;

                            case VS_STILL_PROBE_CONTROL:

                                printf("Still Probe Control\r\n");

                                memcpy(&TempVdoProbeCommit, data, setup_pkt->wLength);

                                break;

                            case VS_COMMIT_CONTROL:

                                printf("Commit Probe Control\r\n");
                                
                                // Once the video player is closed, we receive the clear feature request. 
                                // As a result, we are enabling bulk streaming. The device will prevent 
                                // the initiation of U1 and U2, and the controller will reject both U1 and U2.
								//printf("CP_Dis\r\n");
								lsc_set_u1_sleep(usb_dev, U1U2_DIS);

								lsc_set_u2_sleep(usb_dev, U1U2_DIS);
								lsc_usb_accept_u1u2_sleep(usb_dev, U1U2_DIS);

                                memcpy(&TempVdoProbeCommit, data, setup_pkt->wLength);

                                vdoProbeCommit.bmHint.val =
                                        TempVdoProbeCommit.bmHint.val;
                                vdoProbeCommit.bFormatIndex =
                                        TempVdoProbeCommit.bFormatIndex;
                                vdoProbeCommit.bFrameIndex =
                                        TempVdoProbeCommit.bFrameIndex;
                                vdoProbeCommit.dwFrameInterval =
                                        TempVdoProbeCommit.dwFrameInterval;
                                vdoProbeCommit.wKeyFrameRate =
                                        TempVdoProbeCommit.wKeyFrameRate;
                                vdoProbeCommit.wPFrameRate =
                                        TempVdoProbeCommit.wPFrameRate;
                                vdoProbeCommit.wCompQuality =
                                        TempVdoProbeCommit.wCompQuality;
                                vdoProbeCommit.wCompWindowSize =
                                        TempVdoProbeCommit.wCompWindowSize;
                                vdoProbeCommit.wDelay =
                                        TempVdoProbeCommit.wDelay;
                                vdoProbeCommit.dwMaxVideoFrameSize =
                                        TempVdoProbeCommit.dwMaxVideoFrameSize;
                                vdoProbeCommit.dwMaxPayloadTransferSize =
                                        TempVdoProbeCommit.dwMaxPayloadTransferSize;
#ifdef UVC1_5
                                //UVC1.1
                                vdoProbeCommit.dwClockFrequency =
                                        TempVdoProbeCommit.dwClockFrequency;
                                vdoProbeCommit.bmFramingInfo =
                                        TempVdoProbeCommit.bmFramingInfo;
                                vdoProbeCommit.bPreferedVersion =
                                        TempVdoProbeCommit.bPreferedVersion;
                                vdoProbeCommit.bMinVersion =
                                        TempVdoProbeCommit.bMinVersion;
                                vdoProbeCommit.bMaxVersion =
                                        TempVdoProbeCommit.bMaxVersion;

                                //UVC1.5
                                vdoProbeCommit.bUsage =
                                        TempVdoProbeCommit.bUsage;
                                vdoProbeCommit.bBitDepthLuma =
                                        TempVdoProbeCommit.bBitDepthLuma;
                                vdoProbeCommit.bmSettings =
                                        TempVdoProbeCommit.bmSettings;
                                vdoProbeCommit.bMaxNumberOfRefFramesPlus1 =
                                        TempVdoProbeCommit.bMaxNumberOfRefFramesPlus1;
                                vdoProbeCommit.bmRateControlModes =
                                        TempVdoProbeCommit.bmRateControlModes;
                                vdoProbeCommit.bmLayoutPerStream[0] =
                                        TempVdoProbeCommit.bmLayoutPerStream[0];
#endif

                                lsc_iebm_buf_mgmt_init();

								lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_CTRL_REG), LSC_IEBM_IP_CNF_MASK);

								straming_en = 1;
                                //Set configured bit in CTRL register

                                break;

                            case VS_STILL_COMMIT_CONTROL:

                                printf("Still Commit Control\r\n");

                                memcpy(&TempVdoProbeCommit, data, setup_pkt->wLength);

                                vdoStillImgProbeComit.bFormatIndex =
                                        TempStillImgVdoProbeCommit.bFormatIndex;
                                vdoStillImgProbeComit.bFrameIndex =
                                        TempStillImgVdoProbeCommit.bFrameIndex;
                                vdoStillImgProbeComit.bCompressionIndex =
                                        TempStillImgVdoProbeCommit.bCompressionIndex;
                                vdoStillImgProbeComit.dwMaxVideoFrameSize =
                                        TempStillImgVdoProbeCommit.dwMaxVideoFrameSize;
                                vdoStillImgProbeComit.dwMaxPayloadTransferSize =
                                        TempStillImgVdoProbeCommit.dwMaxPayloadTransferSize;

                                break;

                            case VS_STILL_IMAGE_TRIGGER_CONTROL:

                                printf("Still Image Trigger Control\r\n");

                                break;

                            default:

                                printf("Unsupported Control Selector\r\n");

                                terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_CTRL;

                                lsc_usb_ep0_stall_restart(usb_dev);

                                return;
                        }

                        break;

                    default:
                        break;
                }
            }
            else
            {
                printf("Unsupported Direction\r\n");

                lsc_usb_ep0_stall_restart(usb_dev);

                terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_WRONG_STATE;

                return;
            }
        }
        else
        {
            printf("Unsupported Interface\r\n");

            terminalErrorCode[VC_ERR_CODE_INDEX] = ERR_CODE_INVALID_UNIT;

            lsc_usb_ep0_stall_restart(usb_dev);

            return;
        }
    }
    else
    {
        printf("Recipient != Interface\r\n");
    }
}


void configure_uvc_device()
{
    unsigned data_size = 0;

    //Video Probe and Commit Control Data Structure

    vdoProbeCommit.bmHint.val = 0x0000;
    vdoProbeCommit.bFormatIndex = 0x01;
    vdoProbeCommit.bFrameIndex = 0x01;
    vdoProbeCommit.dwFrameInterval = 0x51615; //0x00041FBE;//0x00036AD9;//0x0015CC5B;//0x004C4B40;//0x00145000;//0x989680;//0x51615;
    vdoProbeCommit.wKeyFrameRate = 0x00;               //(unsigned int)0x0960;
    vdoProbeCommit.wPFrameRate = 0x0000;
    vdoProbeCommit.wCompQuality = 0x0000;
    vdoProbeCommit.wCompWindowSize = 0x0000;
    vdoProbeCommit.wDelay = 0x0000;
#ifdef UVC_YUY2
    vdoProbeCommit.dwMaxVideoFrameSize = ((WIDTH * HEIGHT * BITSPERPIXEL) / 8)
            + 2;               //0x96002;//25500;//Commented in JPEG hal
    vdoProbeCommit.dwMaxPayloadTransferSize = ((WIDTH * HEIGHT * BITSPERPIXEL)
            / 8) + 2;               //0x96002;//0x0000020C;//84  //Commented in JPEG hal
#else
    vdoProbeCommit.dwMaxVideoFrameSize = 0x003F4800;//JPEG change
    vdoProbeCommit.dwMaxPayloadTransferSize =0x3F4802;//JPEG change
#endif

#ifdef UVC1_5
    //UVC1.1
    vdoProbeCommit.dwClockFrequency=0x00;
    vdoProbeCommit.bmFramingInfo.val=0x00;
    vdoProbeCommit.bPreferedVersion=0x00;
    vdoProbeCommit.bMinVersion=0x00;
    vdoProbeCommit.bMaxVersion=0x00;

    //UVC1.5
    vdoProbeCommit.bUsage=0x00;
    vdoProbeCommit.bBitDepthLuma=0x00;
    vdoProbeCommit.bmSettings=0x00;
    vdoProbeCommit.bMaxNumberOfRefFramesPlus1=0x00;
    vdoProbeCommit.bmRateControlModes=0x00;
    vdoProbeCommit.bmLayoutPerStream[0]=0x00;
#endif

    //Video Still Image Probe and Commit Control Data Structure

    vdoStillImgProbeComit.bFormatIndex = 0x01;
    vdoStillImgProbeComit.bFrameIndex = 0x01;
    vdoStillImgProbeComit.bCompressionIndex = 0x00;                    //0x01;
    vdoStillImgProbeComit.dwMaxVideoFrameSize = 0x00FFFFFF;      //0x00070800;
    vdoStillImgProbeComit.dwMaxPayloadTransferSize = 0x000800; //0x0000020C;//0x0202;

    vdoFormatPayloadHeader.bmHeaderInfo.byte = 0x21;
    vdoFormatPayloadHeader.bHeaderLength = 2;

    bmCtrlsSupported[PU_BMCONTROLS_INDEX] = 0x00000000;
    bmCtrlsSupported[CAM_BMCONTROLS_INDEX] = 0x00000000;
    bmCtrlsSupported[EU_BMCONTROLS_INDEX] = 0x00000001;

    //mapProcUnitCtrl[0]=;
    //procUnitCtrlsVal array Description
    //its row index specifies the control which is supported by processing unit
    //its col index specifies the values supported by processing unit control for min, max,default ,etc
    //0-brightness
    //1-contrast
    //2-hue
    //3-saturation
    //4-sharpness
    //5-gamma
    procUnitCtrlsVal[0][GET_DEF_VAL_INDEX] = 20;
    procUnitCtrlsVal[0][GET_INFO_VAL_INDEX] = 5;
    procUnitCtrlsVal[0][GET_MAX_VAL_INDEX] = 20;
    procUnitCtrlsVal[0][GET_RES_VAL_INDEX] = 20;
    procUnitCtrlsVal[0][GET_MIN_VAL_INDEX] = 20;
    procUnitCtrlsVal[0][GET_CUR_VAL_INDEX] = 20;
    ///*
    //3-contrast
    procUnitCtrlsVal[PU_CONTRAST_CONTROL][GET_DEF_VAL_INDEX] = 0x14;
    procUnitCtrlsVal[PU_CONTRAST_CONTROL][GET_INFO_VAL_INDEX] = 0x5;
    procUnitCtrlsVal[PU_CONTRAST_CONTROL][GET_MAX_VAL_INDEX] = 0x16;
    procUnitCtrlsVal[PU_CONTRAST_CONTROL][GET_RES_VAL_INDEX] = 0x1;
    procUnitCtrlsVal[PU_CONTRAST_CONTROL][GET_MIN_VAL_INDEX] = 0x14;
    procUnitCtrlsVal[PU_CONTRAST_CONTROL][GET_CUR_VAL_INDEX] = 0x14;
    //1-BackLightCompensation
    procUnitCtrlsVal[PU_BACKLIGHT_COMPENSATION_CONTROL][GET_DEF_VAL_INDEX] = 1;
    procUnitCtrlsVal[PU_BACKLIGHT_COMPENSATION_CONTROL][GET_INFO_VAL_INDEX] =
            0x5;
    procUnitCtrlsVal[PU_BACKLIGHT_COMPENSATION_CONTROL][GET_MAX_VAL_INDEX] = 1;
    procUnitCtrlsVal[PU_BACKLIGHT_COMPENSATION_CONTROL][GET_RES_VAL_INDEX] = 1;
    procUnitCtrlsVal[PU_BACKLIGHT_COMPENSATION_CONTROL][GET_MIN_VAL_INDEX] = 1;
    procUnitCtrlsVal[PU_BACKLIGHT_COMPENSATION_CONTROL][GET_CUR_VAL_INDEX] = 1;
    //2-Brightness
    procUnitCtrlsVal[PU_BRIGHTNESS_CONTROL][GET_DEF_VAL_INDEX] = 0x14;
    procUnitCtrlsVal[PU_BRIGHTNESS_CONTROL][GET_INFO_VAL_INDEX] = 0x5;
    procUnitCtrlsVal[PU_BRIGHTNESS_CONTROL][GET_MAX_VAL_INDEX] = 0x7c;
    procUnitCtrlsVal[PU_BRIGHTNESS_CONTROL][GET_RES_VAL_INDEX] = 0x01;
    procUnitCtrlsVal[PU_BRIGHTNESS_CONTROL][GET_MIN_VAL_INDEX] = 0x14;
    procUnitCtrlsVal[PU_BRIGHTNESS_CONTROL][GET_CUR_VAL_INDEX] = 0x14;
    //*/
    //9-Gamma
    procUnitCtrlsVal[PU_GAMMA_CONTROL][GET_DEF_VAL_INDEX] = 0x60;
    procUnitCtrlsVal[PU_GAMMA_CONTROL][GET_INFO_VAL_INDEX] = 0x5;
    procUnitCtrlsVal[PU_GAMMA_CONTROL][GET_MAX_VAL_INDEX] = 0x64;
    procUnitCtrlsVal[PU_GAMMA_CONTROL][GET_RES_VAL_INDEX] = 0x01;
    procUnitCtrlsVal[PU_GAMMA_CONTROL][GET_MIN_VAL_INDEX] = 0x60;
    procUnitCtrlsVal[PU_GAMMA_CONTROL][GET_CUR_VAL_INDEX] = 0x60;
    ///*
    //4-Gain
    procUnitCtrlsVal[PU_GAIN_CONTROL][GET_DEF_VAL_INDEX] = 18;
    procUnitCtrlsVal[PU_GAIN_CONTROL][GET_INFO_VAL_INDEX] = 0x5;
    procUnitCtrlsVal[PU_GAIN_CONTROL][GET_MAX_VAL_INDEX] = 18;
    procUnitCtrlsVal[PU_GAIN_CONTROL][GET_RES_VAL_INDEX] = 1;
    procUnitCtrlsVal[PU_GAIN_CONTROL][GET_MIN_VAL_INDEX] = 1;
    procUnitCtrlsVal[PU_GAIN_CONTROL][GET_CUR_VAL_INDEX] = 18;
    //*/
    ///*
    //7-saturation
    procUnitCtrlsVal[PU_SATURATION_CONTROL][GET_DEF_VAL_INDEX] = 0x6;
    procUnitCtrlsVal[PU_SATURATION_CONTROL][GET_INFO_VAL_INDEX] = 0x5;
    procUnitCtrlsVal[PU_SATURATION_CONTROL][GET_MAX_VAL_INDEX] = 0x10;
    procUnitCtrlsVal[PU_SATURATION_CONTROL][GET_RES_VAL_INDEX] = 0x1;//RES value must always be 1 as per UVC specifications
    procUnitCtrlsVal[PU_SATURATION_CONTROL][GET_MIN_VAL_INDEX] = 0x6;
    procUnitCtrlsVal[PU_SATURATION_CONTROL][GET_CUR_VAL_INDEX] = 0x6;
    //6-hue
    procUnitCtrlsVal[PU_HUE_CONTROL][GET_DEF_VAL_INDEX] = 0x2;
    procUnitCtrlsVal[PU_HUE_CONTROL][GET_INFO_VAL_INDEX] = 0x5;
    procUnitCtrlsVal[PU_HUE_CONTROL][GET_MAX_VAL_INDEX] = 0x4;
    procUnitCtrlsVal[PU_HUE_CONTROL][GET_RES_VAL_INDEX] = 0x1;
    procUnitCtrlsVal[PU_HUE_CONTROL][GET_MIN_VAL_INDEX] = 0x2;
    procUnitCtrlsVal[PU_HUE_CONTROL][GET_CUR_VAL_INDEX] = 0x2;
    //8-sharpness
    procUnitCtrlsVal[PU_SHARPNESS_CONTROL][GET_DEF_VAL_INDEX] = 0x28;
    procUnitCtrlsVal[PU_SHARPNESS_CONTROL][GET_INFO_VAL_INDEX] = 0x5;
    procUnitCtrlsVal[PU_SHARPNESS_CONTROL][GET_MAX_VAL_INDEX] = 0x2A;
    procUnitCtrlsVal[PU_SHARPNESS_CONTROL][GET_RES_VAL_INDEX] = 0x01;
    procUnitCtrlsVal[PU_SHARPNESS_CONTROL][GET_MIN_VAL_INDEX] = 0x28;
    procUnitCtrlsVal[PU_SHARPNESS_CONTROL][GET_CUR_VAL_INDEX] = 0x28;


    ExtenUnitCtrlsVal[0][GET_DEF_VAL_INDEX] = 0x0;
    ExtenUnitCtrlsVal[0][GET_INFO_VAL_INDEX] =  0x0;
    ExtenUnitCtrlsVal[0][GET_MAX_VAL_INDEX] =  0x0;
    ExtenUnitCtrlsVal[0][GET_RES_VAL_INDEX] =  0x0;
    ExtenUnitCtrlsVal[0][GET_MIN_VAL_INDEX] =  0x0;
    ExtenUnitCtrlsVal[0][GET_CUR_VAL_INDEX] =  0x0;
}

/** @} */
