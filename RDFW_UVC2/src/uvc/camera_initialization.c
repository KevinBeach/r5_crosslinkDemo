// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file camera_initialization.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/
 
#include "../utils.h"
#include "i2c_master.h"
#include "i2c_master_regs.h"
#include "uvc/camera_initialization.h"

uint8_t tx_config_buf[3];
extern struct i2cm_instance i2c_master_core;

void mode_default_register_init()
{
	    for ( int i = 0; i < sizeof(mode_table_common); i = i + 3)
        {
            tx_config_buf[0]=mode_table_common[i];
            tx_config_buf[1]=mode_table_common[i+1];
            tx_config_buf[2]=mode_table_common[i+2];


            i2c_master_write (&i2c_master_core,
                              TRGT_SLV_ADDR,
                              0x3,  // Every time fix 2 byte of offset address
                              tx_config_buf // Tx length
                              );

            delayMS(5);

        }
}

void usb2_cam_pll_setting()
{
		    for ( int i = 0; i < sizeof(cam_pll_setting_u2); i = i + 3)
        {
            tx_config_buf[0]=cam_pll_setting_u2[i];
            tx_config_buf[1]=cam_pll_setting_u2[i+1];
            tx_config_buf[2]=cam_pll_setting_u2[i+2];


            i2c_master_write (&i2c_master_core,
                              TRGT_SLV_ADDR,
                              0x3,  // Every time fix 2 byte of offset address
                              tx_config_buf // Tx length
                              );

            delayMS(5);

        }
}

void usb3_cam_pll_setting()
{
		    for ( int i = 0; i < sizeof(cam_pll_setting_u3); i = i + 3)
        {
            tx_config_buf[0]=cam_pll_setting_u3[i];
            tx_config_buf[1]=cam_pll_setting_u3[i+1];
            tx_config_buf[2]=cam_pll_setting_u3[i+2];


            i2c_master_write (&i2c_master_core,
                              TRGT_SLV_ADDR,
                              0x3,  // Every time fix 2 byte of offset address
                              tx_config_buf // Tx length
                              );

            delayMS(5);

        }
}

void set_resolution()
{
//		for ( int i = 0; i < sizeof(mode_1280x720); i = i + 3)
//        {
//            tx_config_buf[0]=mode_1280x720[i];
//            tx_config_buf[1]=mode_1280x720[i+1];
//            tx_config_buf[2]=mode_1280x720[i+2];
//
//
//            i2c_master_write (&i2c_master_core,
//            		          TRGT_SLV_ADDR,
//                              0x3,  // Every time fix 2 byte of offset address
//                              tx_config_buf // Tx length
//                              );
//
//            delayMS(5);
//        }

		for ( int i = 0; i < sizeof(mode_1920x1080); i = i + 3)
        {
            tx_config_buf[0]=mode_1920x1080[i];
            tx_config_buf[1]=mode_1920x1080[i+1];
            tx_config_buf[2]=mode_1920x1080[i+2];


            i2c_master_write (&i2c_master_core,
            		          TRGT_SLV_ADDR,
                              0x3,  // Every time fix 2 byte of offset address
                              tx_config_buf // Tx length
                              );

            delayMS(5);
        }

}

void enable_camera()
{
	   	for ( int i = 0; i < sizeof(cam_en); i = i + 3)
    	{
    		delayMS (5);
    		tx_config_buf[0]=cam_en[i];
    		tx_config_buf[1]=cam_en[i+1];
    		tx_config_buf[2]=cam_en[i+2];


    		i2c_master_write (&i2c_master_core,
    				TRGT_SLV_ADDR,
					0x3,  // Every time fix 2 byte of offset address
					tx_config_buf // Tx length
					);
    	}
}

void disable_camera()
{
	   	for ( int i = 0; i < sizeof(cam_dis); i = i + 3)
    	{
    		delayMS (5);
    		tx_config_buf[0]=cam_dis[i];
    		tx_config_buf[1]=cam_dis[i+1];
    		tx_config_buf[2]=cam_dis[i+2];


    		i2c_master_write (&i2c_master_core,
    				TRGT_SLV_ADDR,
					0x3,  // Every time fix 2 byte of offset address
					tx_config_buf // Tx length
					);
    	}
}

/** @} */