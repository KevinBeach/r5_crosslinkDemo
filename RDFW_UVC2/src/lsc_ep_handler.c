// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file lsc_ep_handler.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/

#include <stdio.h>
#include "lsc_usb_dev.h"

//#define DEBUG_LSC_EP_HANDLER

#ifdef DEBUG_LSC_EP_HANDLER
#define LSC_EP_HANDLER(msg, ...) sprintf(print_buf, msg, ##__VA_ARGS__); lsc_uart_tx(print_buf)
#else
#define LSC_EP_HANDLER(msg, ...)
#endif

extern struct lsc_usb_dev_dm usb_dev_dm __attribute__((section(".myBufSection")));
/****************************************************************************/
/**
 * @brief
 * This function enqueues buffer details for a specified endpoint.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is the USB endpoint number.
 * @param    dir is the direction of the endpoint.
 * @param    buf is a pointer to the buffer.
 * @param    buf_len is the length of the buffer.
 *
 * @return   Returns LSC_SUCCESS if the operation is successful, otherwise returns LSC_FAIL.
 *
 * @note     None.
 ****************************************************************************/
uint8_t lsc_usb_ep_buf_queue (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir, uint8_t *buf, uint32_t buf_len)
{
    LSC_EP_HANDLER("lsc_usb_ep_buf_queue\r\n");

    uint8_t phy_ep_num = 0;
    struct lsc_ep *ep = NULL;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);

    ep = &usb_dev->eps[phy_ep_num];

    // Check if the current buffer index has no pending events
    if (!(ep->ep_buf_i[ep->ep_buf_i_enqueue].no_of_event)) {

        // Assign the buffer pointer and size to the current buffer index
        ep->ep_buf_i[ep->ep_buf_i_enqueue].buf_ptr = buf;
        ep->ep_buf_i[ep->ep_buf_i_enqueue].buf_size = buf_len;

        // Calculate the number of events for the identified after that number of events we dequeue the this index of buffer details clear
        // This is done by dividing the buffer length by the maximum TRB size
        ep->ep_buf_i[ep->ep_buf_i_enqueue].no_of_event =
                (buf_len / MAX_TRB_SIZE);

        // If there is space for a short packet in the buffer length, increment the number of events by 1 only
        if (buf_len % MAX_TRB_SIZE) {
            ep->ep_buf_i[ep->ep_buf_i_enqueue].no_of_event++;
        }

        LSC_EP_HANDLER("Enqueued %d Buffer: %p, Buffer Size: %d\r\n", ep->ep_buf_i_enqueue,
                ep->ep_buf_i[ep->ep_buf_i_enqueue].buf_ptr, ep->ep_buf_i[ep->ep_buf_i_enqueue].buf_size);

        // Increment the enqueue index
        ep->ep_buf_i_enqueue++;

        // If the enqueue index reaches the maximum, reset it to zero
        if (ep->ep_buf_i_enqueue == NO_OF_BUF) {
            ep->ep_buf_i_enqueue = 0;
        }

        // Return success if the operation completed successfully
        return LSC_SUCCESS;

    } else {

        // This print statement signifies that the Queue is full and the stored buffer has not yet been dequeued.
        //If you need to store more buffers in the Queue, you can increase the size of the Queue.
        //This can be done by adjusting the value of the 'MAX' macro defined in the lsc_usb_dev.h file.

        printf("Queue is Full enqueue %d, no_of_event %d, size %d\r\n", ep->ep_buf_i_enqueue,
                ep->ep_buf_i[ep->ep_buf_i_enqueue].no_of_event, ep->ep_buf_i[ep->ep_buf_i_enqueue].buf_size);

        // Return failure if the queue is full
        return LSC_FAIL;
    }
}

/****************************************************************************/
/**
 * @brief
 * Stops transfer on Endpoint.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    dir is direction of endpoint
 *               - LSC_EP_DIR_IN/ LSC_EP_DIR_OUT.
 * @param    force flag to stop/pause transfer.
 *
 * @return   None.
 *
 * @note     None.
 ****************************************************************************/
void lsc_usb_stop_xfer (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir, uint8_t force)
{
    LSC_EP_HANDLER("lsc_usb_stop_xfer\r\n");

    uint8_t phy_ep_num;
    uint32_t cmd;
    struct lsc_ep *ep;
    struct lsc_ep_params *params;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);
    ep = &usb_dev->eps[phy_ep_num];

    params = lsc_usb_get_ep_params(usb_dev);

    if (ep->resource_index == 0) {
        return;
    }

    /*
     * - Issue EndTransfer WITH CMDIOC bit set
     * - Wait 100us
     */
    cmd = LSC_DEPCMD_ENDTRANSFER;
    cmd |= (force == 1) ? LSC_DEPCMD_HIPRI_FORCERM : 0;
    cmd |= LSC_DEPCMD_CMDIOC;
    cmd |= LSC_DEPCMD_PARAM(ep->resource_index);

    lsc_usb_send_ep_cmd(usb_dev, ep->usb_ep_num, ep->ep_direction, cmd, params);
    if (force == 1) {
        ep->resource_index = 0;
    }

    ep->ep_status &= ~LSC_EP_BUSY;

    ep->trb_enqueue = 0;
    ep->trb_dequeue = 0;
    ep->requested_bytes = 0;
    ep->remain_bytes = 0;
    ep->bytes_txfered = 0;
    ep->buffer_ptr = NULL;
    ep->ep_buf_i_enqueue = 0;
    ep->ep_buf_i_rd = 0;
    ep->ep_buf_i_dequeue = 0;

    /* struct lsc_ep_buf_info lsc_ep_buf_i[MAX] clearing */
    memset(ep->ep_buf_i, 0, sizeof(struct lsc_ep_buf_info) * NO_OF_BUF);

    //Here only trb strucutre clear without link trb
//    memset(ep->ep_trb, 0, sizeof(struct lsc_trb) * (NO_OF_TRB_PER_EP));
    memset(&(usb_dev_dm.ep_trb[phy_ep_num][0]), 0, sizeof(struct lsc_trb) * (NO_OF_TRB_PER_EP));

    lsc_usb_usleep(100);
}

/****************************************************************************/
/**
 * @brief
 * Clears Stall on an Endpoint.
 * Clear Stall (DEPCSTALL) is issued on endpoint to clear stall.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    dir is direction.
 *
 * @return   None.
 *
 * @note     The application must not issue the Clear Stall command
 *           on a control endpoint.<br>
 *           Refer sec 3.2.2.4 of Synopsis Programming Guide Version 3.30b
 *           for Clear Stall (DEPCSTALL).
 *****************************************************************************/
void lsc_usb_ep_clear_stall (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir)
{
    LSC_EP_HANDLER("lsc_usb_ep_clear_stall\r\n");

    uint8_t phy_ep_num;
    struct lsc_ep *ep;
    struct lsc_ep_params *params;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);
    ep = &usb_dev->eps[phy_ep_num];

    params = lsc_usb_get_ep_params(usb_dev);

    lsc_usb_send_ep_cmd(usb_dev, ep->usb_ep_num, ep->ep_direction,
    LSC_DEPCMD_CLEARSTALL, params);

    ep->ep_status &= ~LSC_EP_STALL;

    //Reset ep status of Non- control endpoint

    ep->ep_status &= ~LSC_EP_BUSY;

}

/****************************************************************************/
/**
 * @brief
 * Checks the Data Phase and calls user Endpoint handler.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    ep_evt is a pointer to the Endpoint event occurred in core.
 *
 * @return   None.
 *
 * @note     None.
 *****************************************************************************/
void lsc_usb_ep_xfer_cmplt (struct lsc_usb_dev *usb_dev,
        const struct lsc_event_epevt *ep_evt)
{
    //This function is invoked by two different events. XFER COMPLETE event and XFER IN PROGRESS.
    //The endpoint handling is identical for both, except for two additional operations required for the XFER COMPLETE event.
    //We use a conditional statement to determine which event received.

    if (ep_evt->ep_event == LSC_DEPEVT_XFERCOMPLETE) {
        LSC_EP_HANDLER("LSC_DEPEVT_XFERCOMPLETE\r\n");
    } else {
        LSC_EP_HANDLER("lsc_usb_ep_xfer_in_progress\r\n");
    }

    struct lsc_trb *trb;
    struct lsc_ep *ep;

    uint32_t len, txfered_bytes, size;
    uint8_t dir, phy_ep_num, ep_num;

    phy_ep_num = ep_evt->ep_number;
    ep = &usb_dev->eps[phy_ep_num];
    dir = ep->ep_direction;
//    trb = &ep->ep_trb[ep->trb_dequeue];
    trb = &usb_dev_dm.ep_trb[phy_ep_num][ep->trb_dequeue];
    ep_num = phy_ep_num >> 1;

    len = trb->size & LSC_TRB_SIZE_MASK;

    LSC_EP_HANDLER("ep %d dir %d trb %d ctrl 0x%x len %d\r\n", usb_ep_num, dir, ep->trb_dequeue, trb->ctrl, len);

    ep->trb_dequeue++;
    if (ep->trb_dequeue == NO_OF_TRB_PER_EP) {
        ep->trb_dequeue = 0;
    }

    // If a complete transfer event is received, the controller ends the streaming for that endpoint. Consequently, we clear these flags.
    if (ep_evt->ep_event == LSC_DEPEVT_XFERCOMPLETE) {
        ep->ep_status &= ~(LSC_EP_BUSY);
        ep->resource_index = 0;
    }

    // This is used to manage the dequeue buffer, which holds the number of events that need to be received.
    // After these events are received, the dequeue buffer details are cleared.
    if (ep->ep_buf_i[ep->ep_buf_i_dequeue].no_of_event) {

        ep->ep_buf_i[ep->ep_buf_i_dequeue].no_of_event--;

    }

    // This condition is used to calculate the appropriate size of the at TRB filled. If the filled TRB is less than MAX_TRB_SIZE,
    // it means the TRB size is equal to the dequeue buffer size. Otherwise, the TRB is filled with MAX_TRB_SIZE.
    if (ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size < MAX_TRB_SIZE) {

        size = ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size;

    } else {

        size = MAX_TRB_SIZE;

    }

    // The operation below calculates the actual number of bytes transmitted or received by the device.
    // If this condition is true, it indicates that the available size for the TRB was not fully utilized. Otherwise, it implies that the full size was used.
    // For the 'out' direction, this event is generated under two conditions: 1) if the host sends data of maximum TRB size, 2) if the host sends a short packet of data.
    // For the 'in' direction, this event is generated only under one condition: when the data of TRB size has been fully transferred to the host.
    // If any other case occurs, it could suggest an error with the TRB size.
    if (len) {

        if (dir == LSC_EP_DIR_IN) {

            // If this occurs in the 'in' direction, it could suggest an error.
            LSC_EP_HANDLER("For the 'in' direction, this case should not occur. TRB size= %d\r\n",trb->size);

        } else {

            // This could be because the host sent a short packet in the 'out' direction.

            // Calculate the actual number of bytes transmitted by the host
            txfered_bytes = (size - len);

            LSC_EP_HANDLER("Short packet received: %d\r\n", txfered_bytes);
        }

    } else {

        // The TRB used the full space as indicated by the size when the TRB was filled.
        txfered_bytes = size;
    }

    ep->bytes_txfered += txfered_bytes;

    LSC_EP_HANDLER("ep->bytes_txfered :%x main_deque_buf:%x\r\n",
            ep->bytes_txfered, ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size);

#ifdef LOOPBACK
    //normal out and in transfer flow and Loopback flow quite differet

    if (dir == LSC_EP_DIR_IN) {

        LSC_EP_HANDLER("txfered_bytes from in ep %d\r\n", txfered_bytes);

        // For every 'xfer_cmplt' or 'xfer_in_progress' event in the loopback test, we dequeue a buffer from the 'in' direction endpoint queue and clear the buffer details.
        // This is because, during loopback testing, for every 'xfer_cmplt' or 'xfer_in_progress' event of the 'out' direction endpoint,
        // we store a new buffer in the 'in' direction endpoint queue.
        if (!ep->ep_buf_i[ep->ep_buf_i_dequeue].no_of_event) {

            //Result of dequeue buffer
            //Note:- For the 'in' direction endpoint, the values of 'ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size' and 'ep->bytes_txfered' should be the same.
            LSC_EP_HANDLER("dequeue %d deque_buf_size : %d  txfered : %d\r\n", ep->ep_buf_i_dequeue ,ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size, ep->bytes_txfered);

            //clear due to dequeue buffer now clear and after that new dequeue buffer event we received so new dequeue buffer bytes_txfered details store
            ep->bytes_txfered = 0;

            //clear the dequeue buffer details for new buffer details store at that place
            ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size = 0;
            ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_ptr = 0;

            // Increment the dequeue index
            ep->ep_buf_i_dequeue++;

            // If the dequeue index reaches the maximum, reset it to zero
            if (ep->ep_buf_i_dequeue == NO_OF_BUF) {
                ep->ep_buf_i_dequeue = 0;
            }

        } else {
            // If this case occurs, it suggests there might be an issue in the loopback.
            //This could be due to incorrect calculations or events not being linear during loopback testing.

            // During each 'in' direction test, we fill only one buffer at a time in the loopback, hence the number of events is 1.
            // Therefore, when we receive a 'xfer_cmplt' or 'xfer_in_progress' event for this 'in' direction endpoint, we decrease the number of events, and it becomes zero.
            LSC_EP_HANDLER("this case should not occur no_of_event= %d\r\n",ep->ep_buf_i[ep->ep_buf_i_dequeue].no_of_event);
        }

        // In Loopback testing, for every 'xfer_in_progress' or 'xfer_cmplt' event, whether for 'in' or 'out' direction, their respective handlers are called each time.
        // This is because some parts of the loopback handling are managed within these handlers.
        // mapping phy_ep_num for OUT direction because we called OUT handler due to LOOPBACK testing
        phy_ep_num = lsc_physicalep(LSC_USB_OUT_EP, LSC_EP_DIR_OUT);
        ep = &usb_dev->eps[phy_ep_num];

        if (ep->handler != NULL) {
            ep->handler(usb_dev, LSC_USB_OUT_EP, txfered_bytes);
        }

    } else {

         LSC_EP_HANDLER("received_bytes from out ep %d\r\n", txfered_bytes);

        // The details of the buffer received in the 'out' direction are stored in the 'in' direction endpoint queue.
        // This allows us to verify whether the loopback testing was successful or not.
        lsc_usb_ep_buf_queue(usb_dev, LSC_USB_IN_EP, LSC_EP_DIR_IN, (uint8_t *)trb->buf_ptr_lo,
                txfered_bytes);

        // Result of dequeue buffer
        // Note: It's okay if 'ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size' and 'ep->bytes_txfered' are not equal,
        // because we may have received a short packets on the OUT endpoint.

        LSC_EP_HANDLER("deque_buf %d deque_buf_size : %d  txfered : %d\r\n", ep->ep_buf_i_dequeue ,ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size, ep->bytes_txfered);

        // In this loopback test, we receive a certain number of events for the 'out' direction endpoint for the dequeue buffer.
        // However, we don't clear the details from 'ep->ep_buf_i[ep->ep_buf_i_dequeue]' here because the last event is associated with the 'out' direction endpoint.
        // This last buffer has not yet been sent to the 'in' direction endpoint. So, when we send this last buffer to the 'in' direction endpoint,
        // and receive either a 'xfer_in_progress' or 'xfer_cmplt' event for the 'in' direction endpoint of that TRB,
        // then we clear the 'out' direction buffer details from 'ep->ep_buf_i[ep->ep_buf_i_dequeue]'.

        // In Loopback testing, for every 'xfer_in_progress' or 'xfer_cmplt' event, whether for 'in' or 'out' direction, their respective handlers are called each time.
        // This is because some parts of the loopback handling are managed within these handlers.

        // mapping phy_ep_num for IN direction because we called In handler due to LOOPBACK testing
        phy_ep_num = lsc_physicalep(LSC_USB_IN_EP, LSC_EP_DIR_IN);
        ep = &usb_dev->eps[phy_ep_num];

        if (ep->handler != NULL) {
            ep->handler(usb_dev, LSC_USB_IN_EP, txfered_bytes);
        }

    }


#else

    // After receiving a certain number of events for dequeue then we clear the dequeue buffer details.
    if (!ep->ep_buf_i[ep->ep_buf_i_dequeue].no_of_event) {

        //result of dequeue buffer
        //Note:- if ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size and ep->bytes_txfered are not equal its ok because it may received a shot pkts on out endpoint.
        LSC_EP_HANDLER("dequeue %d Requested_bytes : %d  txfered : %d\r\n", ep->ep_buf_i_dequeue ,ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size, ep->bytes_txfered);

        //clear due to dequeue buffer now clear and after that new dequeue buffer event we received so new dequeue buffer bytes_txfered details store
        ep->bytes_txfered = 0;

        //clear the dequeue buffer details for new buffer details store at that place
        ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size = 0;
        ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_ptr = 0;

        // Increment the dequeue index
        ep->ep_buf_i_dequeue++;

        // If the dequeue index reaches the maximum, reset it to zero
        if (ep->ep_buf_i_dequeue == NO_OF_BUF) {
            ep->ep_buf_i_dequeue = 0;
        }

        // This is used for specific handling in the user class.
        if (usb_dev->lsc_usr_app_handler != NULL) {
            usb_dev->lsc_usr_app_handler(usb_dev, ep_num, dir);
        }

    }

    if (ep->handler != NULL) {
        ep->handler(usb_dev, ep_num, ep->max_ep_size);
    }

#endif

}

/****************************************************************************/
/**
 * @brief
 * Handles Transfer Not Ready event of Non - Control Endpoints.
 * This function is called when controller generates transfer not ready event
 * on non-control endpoint.
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    ep_evt is a pointer to the Endpoint event occurred in core.
 *
 * @return   None.
 *
 * @note     None.
 *
 *****************************************************************************/
void lsc_usb_ep_xfer_not_ready (struct lsc_usb_dev *usb_dev,
        const struct lsc_event_epevt *ep_evt)
{
    LSC_EP_HANDLER("lsc_usb_ep_xfer_not_ready\r\n");

    struct lsc_ep *ep;
    uint32_t ep_num;
    uint32_t cur_uf;
    uint32_t Mask;

    ep_num = ep_evt->ep_number;
    ep = &usb_dev->eps[ep_num];

    if (ep->ep_type == LSC_ENDPOINT_XFER_BULK) {
//      LSC_EP_HANDLER("Bulk ep\r\n");
    }
}

/****************************************************************************/
/**
 * @brief
 * Returns status of endpoint - Stalled or not
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    dir is direction of endpoint
 *               - LSC_EP_DIR_IN/ LSC_EP_DIR_OUT.
 *
 * @return
 *           1 - if stalled
 *           0 - if not stalled
 *
 * @note     None.
 *****************************************************************************/
uint8_t lsc_usb_is_ep_stalled (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir)
{
    LSC_EP_HANDLER("lsc_usb_is_ep_stalled\r\n");

    uint8_t phy_ep_num;
    struct lsc_ep *ep;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);
    ep = &usb_dev->eps[phy_ep_num];

    return (uint32_t)(!!(ep->ep_status & LSC_EP_STALL));
}

/****************************************************************************/
/**
 * @brief
 * Stalls an Endpoint.
 * Set Stall (DEPSSTALL) is issued on endpoint to set stall.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    dir is direction.
 *
 * @return   None.
 *
 * @note     Refer sec 3.2.2.4 of Synopsis Programming Guide Version 3.30b
 *           for Set Stall (DEPSSTALL).
 *****************************************************************************/
void lsc_usb_ep_set_stall (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t dir)
{
    LSC_EP_HANDLER("lsc_usb_ep_set_stall\r\n");

    uint8_t phy_ep_num;
    struct lsc_ep *ep = NULL;
    struct lsc_ep_params *params;

    phy_ep_num = lsc_physicalep(usb_ep_num, dir);
    ep = &usb_dev->eps[phy_ep_num];

    params = lsc_usb_get_ep_params(usb_dev);

    lsc_usb_send_ep_cmd(usb_dev, ep->usb_ep_num, ep->ep_direction,
    LSC_DEPCMD_SETSTALL, params);

    ep->ep_status |= LSC_EP_STALL;
}

/****************************************************************************/
/**
 * @brief
 * Sets an user handler to be called after data is sent/received by an Endpoint
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    epnum is USB endpoint number.
 * @param    dir is direction of endpoint
 *               - LSC_EP_DIR_IN/LSC_EP_DIR_OUT.
 * @param    handler is user handler to be called.
 *
 * @return   None.
 *
 * @note     None.
 *
 *****************************************************************************/
void lsc_set_ep_handler (struct lsc_usb_dev *usb_dev, uint8_t epnum,
        uint8_t dir, void (*handler) (struct lsc_usb_dev*, uint8_t, uint32_t))
{
    LSC_EP_HANDLER("lsc_SetEpHandler\r\n");
    uint8_t phy_ep_num;
    struct lsc_ep *ep = NULL;

    phy_ep_num = lsc_physicalep(epnum, dir);
    ep = &usb_dev->eps[phy_ep_num];
    ep->handler = (void (*) (struct lsc_usb_dev*, uint8_t, uint32_t))handler;
}

/****************************************************************************/
/**
 * @brief
 * Initiates DMA to receive data on Endpoint from Host.
 *
 * @param    usb_dev is pointer to lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    buf is pointer to data. This data buffer is cache-aligned.
 * @param    len is length of data to be received.
 *
 * @return   LSC_SUCCESS else LSC_FAIL
 *
 * @note     This function initiates DMA to receive data on
 *           the endpoint from the Host. The data buffer should be aligned.
 *
 *****************************************************************************/
uint8_t lsc_usb_ep_buf_rcv (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t *buf, uint32_t len)
{
    LSC_EP_HANDLER("lsc_usb_ep_buf_rcv\r\n");
    uint8_t phy_ep_num = 0;
    uint32_t cmd = 0, trb_size = 0;
    uint32_t size = 0;
    uint8_t ret_val = 0;
    struct lsc_trb *trb = NULL;
    struct lsc_ep *ep = NULL;
    struct lsc_ep_params params;

    phy_ep_num = lsc_physicalep(usb_ep_num, LSC_EP_DIR_OUT);
    ep = &usb_dev->eps[phy_ep_num];

    if (ep->ep_direction != LSC_EP_DIR_OUT) {
        return (int)LSC_FAIL;
    }

    ep->buffer_ptr = buf;
    ep->requested_bytes = len;
    ep->remain_bytes = len;
    size = len;

//    trb = &ep->ep_trb[ep->trb_enqueue];
    trb = &usb_dev_dm.ep_trb[phy_ep_num][ep->trb_enqueue];

    if (trb->ctrl & LSC_TRB_CTRL_HWO) {
        // Current TRB is busy
        LSC_EP_HANDLER("trb_bussy = %d ctrl 0x%x\r\n", ep->trb_enqueue,
                trb->ctrl);
        return (int)LSC_FAIL;
    }

    trb->buf_ptr_lo = (uintptr_t)ep->buffer_ptr;
    trb->buf_ptr_hi = ((uintptr_t)ep->buffer_ptr >> 16) >> 16;
    trb_size = tu_min32(ep->remain_bytes, MAX_TRB_SIZE);
    trb->size = trb_size & LSC_TRB_SIZE_MASK;
    ep->remain_bytes -= trb_size;
    ep->buffer_ptr += trb_size;

    switch (ep->ep_type) {

        case LSC_ENDPOINT_XFER_ISOC:
            trb->ctrl = (LSC_TRBCTL_ISOCHRONOUS_FIRST | LSC_TRB_CTRL_CSP);
            break;

        case LSC_ENDPOINT_XFER_INT:
        case LSC_ENDPOINT_XFER_BULK:
#ifdef LINK_TRB_USE
            LSC_EP_HANDLER("Link_trb_flow_use\r\n");
            trb->ctrl = (LSC_TRBCTL_NORMAL | LSC_TRB_CTRL_CSP);
#else
            LSC_EP_HANDLER("Single_trb_flow_use\r\n");
            trb->ctrl = (LSC_TRBCTL_NORMAL | LSC_TRB_CTRL_LST);
#endif
            break;

        default:
            /* Do Nothing. Added for making MISRA-C complaint */
            break;
    }

    trb->ctrl |= (LSC_TRB_CTRL_HWO | LSC_TRB_CTRL_IOC);

    LSC_EP_HANDLER("trb 0x%x ctrl 0x%x len 0x%x\r\n", ep->trb_enqueue,
            trb->ctrl, trb->size);

    ep->trb_enqueue++;
    if (ep->trb_enqueue == NO_OF_TRB_PER_EP) {
        ep->trb_enqueue = 0;
    }

    params.param0 = 0;
    params.param1 = (uintptr_t)trb;
    params.param2 = 0;

    if ((ep->ep_status & LSC_EP_BUSY) != (uint32_t)0) {

        cmd = LSC_DEPCMD_UPDATETRANSFER;
        cmd |= LSC_DEPCMD_PARAM(ep->resource_index);
        params.param1 = 0; // Update transfer no need param value so reset it

        LSC_EP_HANDLER("UPDATE TRANSFER\r\n");

    } else {

        switch (ep->ep_type) {

            case LSC_ENDPOINT_XFER_ISOC:
                buf += len;
                struct lsc_trb *TrbTempNext;
//                TrbTempNext = &ep->ep_trb[ep->trb_enqueue];
                TrbTempNext = &usb_dev_dm.ep_trb[phy_ep_num][ep->trb_enqueue];
                ep->trb_enqueue++;
                if (ep->trb_enqueue == NO_OF_TRB_PER_EP) {
                    ep->trb_enqueue = 0;
                }

                TrbTempNext->buf_ptr_lo = (uintptr_t)buf;
                TrbTempNext->buf_ptr_hi = ((uintptr_t)buf >> 16) >> 16;
                TrbTempNext->size = len & LSC_TRB_SIZE_MASK;
                TrbTempNext->ctrl = (LSC_TRBCTL_ISOCHRONOUS_FIRST
                        | LSC_TRB_CTRL_CSP | LSC_TRB_CTRL_HWO | LSC_TRB_CTRL_IOC
                        | LSC_TRB_CTRL_ISP_IMI);

                cmd |= LSC_DEPCMD_PARAM(ep->cur_micro_frame);
                break;

#ifdef LINK_TRB_USE
            case LSC_ENDPOINT_XFER_INT:
            case LSC_ENDPOINT_XFER_BULK:

                // Check if there are remaining bytes or if there are events in the queue
                if (ep->remain_bytes
                        || (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event)) {

                    // Loop through the number of TRBs per endpoint
                    for (int i = 1; i < NO_OF_TRB_PER_EP; i++) {

                        // If there are no remaining bytes
                        if (!ep->remain_bytes) {

                            // If there are events in the queue
                            if (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event) {

                                // Set the buffer pointer, requested bytes, and remaining bytes from the front of the queue
                                ep->buffer_ptr =
                                        ep->ep_buf_i[ep->ep_buf_i_rd].buf_ptr;
                                ep->requested_bytes =
                                        ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;
                                ep->remain_bytes =
                                        ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;

                                // Increment the front of the queue
                                ep->ep_buf_i_rd++;

                                // If the front of the queue has reached the maximum, reset it to 0
                                if (ep->ep_buf_i_rd == NO_OF_BUF) {
                                    ep->ep_buf_i_rd = 0;
                                }

                            } else {
                                // If there are no more buffers in the queue, log the message and break the loop
                                LSC_EP_HANDLER("No More Buf in nQueue\r\n");
                                break;
                            }

                        }

                        // Get the TRB at the enqueue position
//                        trb = &ep->ep_trb[ep->trb_enqueue];
                        trb = &usb_dev_dm.ep_trb[phy_ep_num][ep->trb_enqueue];

                        // Set the lower and higher parts of the buffer pointer
                        trb->buf_ptr_lo = (uintptr_t)ep->buffer_ptr;
                        trb->buf_ptr_hi = ((uintptr_t)ep->buffer_ptr >> 16)
                                >> 16;

                        // Determine the size of the TRB, which is the minimum of the remaining bytes and the maximum TRB size
                        trb_size = tu_min32(ep->remain_bytes, MAX_TRB_SIZE);
                        trb->size = trb_size;

                        // Subtract the TRB size from the remaining bytes and increment the buffer pointer
                        ep->remain_bytes -= trb_size;
                        ep->buffer_ptr += trb_size;

                        // Set the control flags for the TRB
                        trb->ctrl = (LSC_TRB_CTRL_HWO | LSC_TRBCTL_NORMAL
                                | LSC_TRB_CTRL_IOC | LSC_TRB_CTRL_CSP);

                        // Log the TRB enqueue position, control flags, and size
                        LSC_EP_HANDLER("trb 0x%x ctrl 0x%x len 0x%x\r\n", ep->trb_enqueue, trb->ctrl, trb->size);

                        // Increment the TRB enqueue position
                        ep->trb_enqueue++;

                        // If the TRB enqueue position has reached the number of TRBs per endpoint, reset it to 0
                        if (ep->trb_enqueue == NO_OF_TRB_PER_EP) {
                            ep->trb_enqueue = 0;
                        }

                    }
                }

                break;
#endif

            default:
                break;
        }

        cmd = LSC_DEPCMD_STARTTRANSFER;

        LSC_EP_HANDLER("START TRANSFER\r\n");
    }

    ret_val = lsc_usb_send_ep_cmd(usb_dev, usb_ep_num, ep->ep_direction, cmd,
            &params);
    if (ret_val != LSC_SUCCESS) {
        return LSC_FAIL;
    }

    if ((ep->ep_status & LSC_EP_BUSY) == (uint32_t)0) {
        ep->resource_index = (uint8_t)lsc_usb_ep_get_xfer_index(usb_dev,
                ep->usb_ep_num, ep->ep_direction);
        ep->ep_status |= LSC_EP_BUSY;
    }

    return LSC_SUCCESS;
}

/****************************************************************************/
/**
 * @brief
 * Initiates DMA to send data on endpoint to Host.
 *
 * @param    usb_dev is pointer to lsc_usb_dev instance.
 * @param    usb_ep_num is USB endpoint number.
 * @param    buf is pointer to data. This data buffer is cache-aligned.
 * @param    buf_len is length of data buffer.
 *
 * @return   LSC_SUCCESS else LSC_FAIL
 *
 * @note     This function initiates DMA to send data on
 *           the endpoint towards the Host. The data buffer should be aligned.
 *           DMA is configured using Transfer Request Blocks (TRB).
 *
 *****************************************************************************/
uint8_t lsc_usb_ep_buf_send (struct lsc_usb_dev *usb_dev, uint8_t usb_ep_num,
        uint8_t *buf, uint32_t buf_len)
{
    LSC_EP_HANDLER("lsc_usb_ep_buf_send\r\n");

    uint8_t phy_ep_num = 0;
    uint32_t cmd = 0, trb_size = 0;
    uint8_t ret_val = 0;
    struct lsc_trb *trb = NULL;
    struct lsc_ep *ep = NULL;
    struct lsc_ep_params params;

    phy_ep_num = lsc_physicalep(usb_ep_num, LSC_EP_DIR_IN);
    ep = &usb_dev->eps[phy_ep_num];

    if (ep->ep_direction != LSC_EP_DIR_IN) {
        return (int)LSC_FAIL;
    }

    ep->requested_bytes = buf_len;
    ep->remain_bytes = buf_len;
    ep->buffer_ptr = buf;

//    trb = &ep->ep_trb[ep->trb_enqueue];
    trb = &usb_dev_dm.ep_trb[phy_ep_num][ep->trb_enqueue];

    if (trb->ctrl & LSC_TRB_CTRL_HWO) {
        // Current TRB is busy
        LSC_EP_HANDLER("trb_bussy = %d ctrl 0x%x\r\n", ep->trb_enqueue,
                trb->ctrl);
        return (int)LSC_FAIL;
    }

    trb->buf_ptr_lo = (uintptr_t)ep->buffer_ptr;
    trb->buf_ptr_hi = ((uintptr_t)ep->buffer_ptr >> 16) >> 16;

    trb_size = tu_min32(ep->remain_bytes, MAX_TRB_SIZE);
    trb->size = trb_size & LSC_TRB_SIZE_MASK;

    ep->remain_bytes -= trb_size;
    ep->buffer_ptr += trb_size;

    switch (ep->ep_type) {

        case LSC_ENDPOINT_XFER_ISOC:
            trb->ctrl = (LSC_TRBCTL_ISOCHRONOUS_FIRST | LSC_TRB_CTRL_CSP);
            break;

        case LSC_ENDPOINT_XFER_INT:
        case LSC_ENDPOINT_XFER_BULK:
#ifdef LINK_TRB_USE
            LSC_EP_HANDLER("Link_trb_flow_use\r\n");
            trb->ctrl = (LSC_TRBCTL_NORMAL);
#else
            LSC_EP_HANDLER("Single_trb_flow_use\r\n");
            trb->ctrl = (LSC_TRBCTL_NORMAL | LSC_TRB_CTRL_LST);
#endif
            break;

        default:
            /* Do Nothing. Added for making MISRA-C complaint */
            break;
    }

    trb->ctrl |= (LSC_TRB_CTRL_HWO | LSC_TRB_CTRL_IOC);

    LSC_EP_HANDLER("trb 0x%x ctrl 0x%x len 0x%x\r\n", ep->trb_enqueue,
            trb->ctrl, trb->size);

    ep->trb_enqueue++;
    if (ep->trb_enqueue == NO_OF_TRB_PER_EP) {
        ep->trb_enqueue = 0;
    }

    params.param0 = 0;
    params.param1 = (uintptr_t)trb;
    params.param2 = 0;

    if ((ep->ep_status & LSC_EP_BUSY) != (uint32_t)0) {

        cmd = LSC_DEPCMD_UPDATETRANSFER;
        cmd |= LSC_DEPCMD_PARAM(ep->resource_index);
        params.param1 = 0; // Update transfer no need param value so reset it
        LSC_EP_HANDLER("UPDATE TRANSFER\r\n");

    } else {

        switch (ep->ep_type) {

            case LSC_ENDPOINT_XFER_ISOC:
                buf += buf_len;
                struct lsc_trb *trbtempnext;
//                trbtempnext = &ep->ep_trb[ep->trb_enqueue];
                trbtempnext = &usb_dev_dm.ep_trb[phy_ep_num][ep->trb_enqueue];

                ep->trb_enqueue++;
                if (ep->trb_enqueue == NO_OF_TRB_PER_EP) {
                    ep->trb_enqueue = 0;
                }

                trbtempnext->buf_ptr_lo = (uintptr_t)buf;
                trbtempnext->buf_ptr_hi = ((uintptr_t)buf >> 16) >> 16;
                trbtempnext->size = buf_len & LSC_TRB_SIZE_MASK;
                trbtempnext->ctrl = (LSC_TRBCTL_ISOCHRONOUS_FIRST
                        | LSC_TRB_CTRL_CSP | LSC_TRB_CTRL_HWO | LSC_TRB_CTRL_IOC
                        | LSC_TRB_CTRL_ISP_IMI);
                cmd |= LSC_DEPCMD_PARAM(ep->cur_micro_frame);
                break;

#ifdef LINK_TRB_USE
            case LSC_ENDPOINT_XFER_INT:
            case LSC_ENDPOINT_XFER_BULK:

                // Check if there are remaining bytes or if there are events in the queue
                if (ep->remain_bytes
                        || (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event)) {

                    // Loop through the number of TRBs per endpoint
                    for (int i = 1; i < NO_OF_TRB_PER_EP; i++) {

                        // If there are no remaining bytes
                        if (!ep->remain_bytes) {

                            // If there are events in the queue
                            if (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event) {

                                // Set the buffer pointer, requested bytes, and remaining bytes from the front of the queue
                                ep->buffer_ptr =
                                        ep->ep_buf_i[ep->ep_buf_i_rd].buf_ptr;
                                ep->requested_bytes =
                                        ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;
                                ep->remain_bytes =
                                        ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;

                                // Increment the front of the queue
                                ep->ep_buf_i_rd++;

                                // If the front of the queue has reached the maximum, reset it to 0
                                if (ep->ep_buf_i_rd == NO_OF_BUF) {
                                    ep->ep_buf_i_rd = 0;
                                }

                            } else {
                                // If there are no more buffers in the queue, log the message and break the loop
                                LSC_EP_HANDLER("No More Buf in nQueue\r\n");
                                break;
                            }

                        }

                        // Get the TRB at the enqueue position
//                        trb = &ep->ep_trb[ep->trb_enqueue];
                        trb = &usb_dev_dm.ep_trb[phy_ep_num][ep->trb_enqueue];

                        // Set the lower and higher parts of the buffer pointer
                        trb->buf_ptr_lo = (uintptr_t)ep->buffer_ptr;
                        trb->buf_ptr_hi = ((uintptr_t)ep->buffer_ptr >> 16)
                                >> 16;

                        // Determine the size of the TRB, which is the minimum of the remaining bytes and the maximum TRB size
                        trb_size = tu_min32(ep->remain_bytes, MAX_TRB_SIZE);
                        trb->size = trb_size;

                        // Subtract the TRB size from the remaining bytes and increment the buffer pointer
                        ep->remain_bytes -= trb_size;
                        ep->buffer_ptr += trb_size;

                        // Set the control flags for the TRB
                        trb->ctrl = (LSC_TRB_CTRL_HWO | LSC_TRBCTL_NORMAL
                                | LSC_TRB_CTRL_IOC);

                        // Log the TRB enqueue position, control flags, and size
                        LSC_EP_HANDLER("trb 0x%x ctrl 0x%x len 0x%x\r\n", ep->trb_enqueue, trb->ctrl, trb->size);

                        // Increment the TRB enqueue position
                        ep->trb_enqueue++;

                        // If the TRB enqueue position has reached the number of TRBs per endpoint, reset it to 0
                        if (ep->trb_enqueue == NO_OF_TRB_PER_EP) {
                            ep->trb_enqueue = 0;
                        }

                    }
                }

                break;
#endif

            default:
                /* Do Nothing. Added for making MISRA-C complaint */
                break;

        }

        cmd = LSC_DEPCMD_STARTTRANSFER;
        LSC_EP_HANDLER("START TRANSFER\r\n");
    }

    ret_val = lsc_usb_send_ep_cmd(usb_dev, usb_ep_num, ep->ep_direction, cmd,
            &params);

    if (ret_val != LSC_SUCCESS) {
        return LSC_FAIL;
    }

    if ((ep->ep_status & LSC_EP_BUSY) == (uint32_t)0) {

        ep->resource_index = (uint8_t)lsc_usb_ep_get_xfer_index(usb_dev,
                ep->usb_ep_num, ep->ep_direction);
        ep->ep_status |= LSC_EP_BUSY;

    }

    return LSC_SUCCESS;
}

/** @} */
