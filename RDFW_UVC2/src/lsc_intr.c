// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file lsc_intr.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/

#include <stdio.h>
#include "lsc_usb_dev.h"
#include "gpio_regs.h"

//#define DEBUG_LSC_INTR

#ifdef DEBUG_LSC_INTR
#define LSC_INTR(msg, ...) sprintf(print_buf, msg, ##__VA_ARGS__); lsc_uart_tx(print_buf)
#else
#define LSC_INTR(msg, ...)
#endif

extern struct lsc_usb_dev_dm usb_dev_dm __attribute__((section(".myBufSection")));

/*****************************************************************************/
/**
 * @brief
 * Enables an interrupt in Device Event Enable Register.
 *
 * @param  usb_dev is a pointer to the lsc_usb_dev instance.
 * @param  mask is the OR of any Interrupt Enable Masks:
 *       - LSC_DEVTEN_VNDRDEVTSTRCVEDEN
 *       - LSC_DEVTEN_EVNTOVERFLOWEN
 *       - LSC_DEVTEN_CMDCMPLTEN
 *       - LSC_DEVTEN_ERRTICERREN
 *       - LSC_DEVTEN_SOFEN
 *       - LSC_DEVTEN_EOPFEN
 *       - LSC_DEVTEN_HIBERNATIONREQEVTEN
 *       - LSC_DEVTEN_WKUPEVTEN
 *       - LSC_DEVTEN_ULSTCNGEN
 *       - LSC_DEVTEN_CONNECTDONEEN
 *       - LSC_DEVTEN_USBRSTEN
 *       - LSC_DEVTEN_DISCONNEVTEN
 *
 * @return  None
 *
 * @note    Refer sec 1.3.3 of Synopsis Programming Guide Version 3.30b
 *          for more information about Device Event Enable Register (DEVTEN).
 ******************************************************************************/
void lsc_usb_enable_int (struct lsc_usb_dev *usb_dev, uint32_t mask)
{
    LSC_INTR("lsc_usb_enable_int\r\n");

    uint32_t reg_val = 0;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DEVTEN);
    reg_val |= mask;

    lsc_32_write((usb_dev->base_add + LSC_DEVTEN), reg_val);
}

/*****************************************************************************/
/**
 * @brief
 * Disables an interrupt in Device Event Enable Register.
 *
 * @param  usb_dev is a pointer to the lsc_usb_dev instance.
 * @param  mask is the OR of Interrupt Enable Masks
 *       - LSC_DEVTEN_VNDRDEVTSTRCVEDEN
 *       - LSC_DEVTEN_EVNTOVERFLOWEN
 *       - LSC_DEVTEN_CMDCMPLTEN
 *       - LSC_DEVTEN_ERRTICERREN
 *       - LSC_DEVTEN_SOFEN
 *       - LSC_DEVTEN_EOPFEN
 *       - LSC_DEVTEN_HIBERNATIONREQEVTEN
 *       - LSC_DEVTEN_WKUPEVTEN
 *       - LSC_DEVTEN_ULSTCNGEN
 *       - LSC_DEVTEN_CONNECTDONEEN
 *       - LSC_DEVTEN_USBRSTEN
 *       - LSC_DEVTEN_DISCONNEVTEN
 *
 * @return  None
 *
 * @note    Refer sec 1.3.3 of Synopsis Programming Guide Version 3.30b
 *          for more information about Device Event Enable Register (DEVTEN).
 ******************************************************************************/
void lsc_usb_disable_int (struct lsc_usb_dev *usb_dev, uint32_t mask)
{
    LSC_INTR("lsc_usb_disable_int\r\n");

    uint32_t reg_val = 0;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DEVTEN);
    reg_val &= ~mask;

    lsc_32_write((usb_dev->base_add + LSC_DEVTEN), reg_val);
}

/****************************************************************************/
/**
 * Processes an Event generated by controller. Events are either
 * Device/Endpoint specific event.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    event is the Event entry.
 *
 * @return   None.
 *
 * @note     None.
 *****************************************************************************/
void lsc_usb_evt_handler (struct lsc_usb_dev *usb_dev,
        const union lsc_event *event)
{
//    LSC_INTR("lsc_usb_evt_handler\r\n");

    if (event->evt_type.is_dev_evt == 0) {
        //End point Specific Event
        lsc_usb_ep_event(usb_dev, &event->ep_evt);
        return;
    }

    switch (event->evt_type.type) {
        case LSC_EVENT_TYPE_DEV:
            //Device Specific Event
            lsc_usb_dev_event(usb_dev, &event->dev_evt);
            break;

        default:
            //LSC_INTR("Invalid Events.!!\r\n");
            break;
    }
}

/****************************************************************************/
/**
 * @brief
 * Main USB Controller Interrupt Handler.
 *
 * @param    context is a void pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     None.
 *****************************************************************************/
void lsc_usb_int_handler (void *context)
{
    LSC_INTR("lsc_usb_int_handler\r\n");

    struct lsc_usb_dev *l_usb_dev;
    struct lsc_evt_buffer *evt;

    uint32_t evt_count = 0, reg_val = 0;

    l_usb_dev = (struct lsc_usb_dev*)context;
    evt = &l_usb_dev->evt;

    evt_count = lsc_32_read(l_usb_dev->base_add + LSC_GEVNTCOUNT(0));
    //LSC_INTR("evt_count: %x\r\n", evt_count);

    evt_count &= LSC_GEVNTCOUNT_MASK; //bit0_1 in tihs mask is kept as 0 because every event is of 4 byte.

    //Return, if evt_count is 0
    if (evt_count == 0) {
        return;
    }

    evt->count = evt_count;
    evt->flags |= LSC_EVENT_PENDING;

    //Mask event interrupt
    reg_val = lsc_32_read(l_usb_dev->base_add + LSC_GEVNTSIZ(0));
    reg_val |= LSC_GEVNTSIZ_INTMASK;
    lsc_32_write((l_usb_dev->base_add + LSC_GEVNTSIZ(0)), reg_val);

    lsc_usb_evt_buf_handler(l_usb_dev);
}

/****************************************************************************/
/**
 * Link Status Change Interrupt handler.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    evt_info is Event information.
 *
 * @return   None.
 *
 * @note     For more information about changes link state
 *           read Device Status Register (DSTS).<br>
 *           Bit[21:18] of DSTS represents various USB Link states.<br>
 *           Refer sec 1.3.4 of Synopsis Programming Guide Version 3.30b
 *           for more information about Device Status Register (DSTS).
 *****************************************************************************/
void lsc_usb_link_sts_change_int (struct lsc_usb_dev *usb_dev,
        uint32_t evt_info)
{
    LSC_INTR("lsc_usb_link_sts_change_int\r\n");

    usb_dev->link_state = (evt_info & LSC_LINK_STATE_MASK);

    lsc_read_dev_status_reg(usb_dev);
}

/****************************************************************************/
/**
 * Connection Done Interrupt handler.
 * This function performs initialization of controller when device is
 * attached to the HOST.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is called when controller genrates Device
 *           Connect Event.<br>
 *           Refer sec 4.1.3 of Synopsis Programming Guide Version 3.30b
 *           for more information about Initialization on Connect Event.
 *****************************************************************************/
void lsc_usb_connect_int (struct lsc_usb_dev *usb_dev)
{
    LSC_INTR("lsc_usb_connect_int\r\n");

    uint32_t reg_val = 0;
    uint16_t size = 0;
    uint8_t speed;

    uint32_t hw_ver = lsc_32_read(HW_VER_GPIO_INST_BASE_ADDR);
    LSC_INTR("FPGA Version: %x.%x.%x.%x\r\n", ((hw_ver >> 24) & 0xFF), ((hw_ver >> 16) & 0xFF), ((hw_ver >> 8) & 0xFF), (hw_ver & 0xFF));

    LSC_INTR( "RISC V Version: %x.%x\r\n", ((LSC_RISCV_VER >> 4) & 0xF), (LSC_RISCV_VER & 0xF));

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DSTS);
    speed = reg_val & LSC_DSTS_CONNECTSPD;
    usb_dev->dev_speed = speed;

    switch (speed) {
        case LSC_DCFG_SUPERSPEED:
            LSC_INTR("Super Speed\r\n");
            size = 512;
            usb_dev->dev_speed = LSC_SPEED_SUPER;
            break;

        case LSC_DCFG_HIGHSPEED:
            LSC_INTR("High Speed\r\n");
            size = 64;
            usb_dev->dev_speed = LSC_SPEED_HIGH;
            break;

        case LSC_DCFG_FULLSPEED2:
        case LSC_DCFG_FULLSPEED1:
            LSC_INTR("Full Speed\r\n");
            size = 64;
            usb_dev->dev_speed = LSC_SPEED_FULL;
            break;

        case LSC_DCFG_LOWSPEED:
            LSC_INTR("Low Speed\r\n");
            size = 64;
            usb_dev->dev_speed = LSC_SPEED_LOW;
            break;
        default:
            LSC_INTR("Unknown Speed\r\n");
            size = 64;
            break;
    }

    if (usb_dev->dev_speed == LSC_SPEED_SUPER) {
        reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);
        reg_val &= ~LSC_DCTL_HIRD_THRES_MASK;
        lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);
    }

    ////////////////// For LPM Support //////////////////

#ifdef LSC_LPM_ENABLE
    //Enable LPM Support
    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCFG);
    reg_val |= LSC_DCFG_LPM_CAP;
    lsc_32_write((usb_dev->base_add + LSC_DCFG), reg_val);

    reg_val = lsc_32_read(usb_dev->base_add + LSC_GUCTL1);
//        reg_val |= 0x80000000;   //bit_31 - DEV_DECOUPLE_L1L2_EVT
    reg_val |= 0x1000000;   //bit_24 - DEV_L1_EXIT_BY_HW
    lsc_32_write((usb_dev->base_add + LSC_GUCTL1), reg_val);

    //As of now not needed for LPM L1 USB CV CH9 Test.
//    reg_val = lsc_32_read(usb_dev->base_add + LSC_GUCTL1);
//    reg_val |= 0x1000000;   //bit_24 - DEV_L1_EXIT_BY_HW
//    lsc_32_write((usb_dev->base_add + LSC_GUCTL1), reg_val);
//
//    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);
//    reg_val |= LSC_DCTL_HIRD_THRES(0xF);
//    reg_val &= ~LSC_DCTL_APPL1RES;
//    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

#else
    //Disable LPM Support
    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCFG);
    reg_val &= ~LSC_DCFG_LPM_CAP;
    lsc_32_write((usb_dev->base_add + LSC_DCFG), reg_val);
#endif
    ////////////////// For LPM Support //////////////////
    lsc_iebm_buf_mgmt_init();
    lsc_usb_enable_ctrl_ep(usb_dev, size);
    lsc_usb_rcv_setup(usb_dev);
}

/****************************************************************************/
/**
 * Disconnect Interrupt handler.
 * This function performs initialization of controller when device is
 * disconnected from the HOST.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is called when controller genrates Device
 *           Disconnect Event.<br>
 *           Refer sec 4.1.7 of Synopsis Programming Guide Version 3.30b
 *           for more information about Initialization on Disconnect Event.
 *****************************************************************************/
void lsc_usb_disconn_int (struct lsc_usb_dev *usb_dev)
{
    LSC_INTR("lsc_usb_disconn_int\r\n");

    uint32_t reg_val = 0;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);

    reg_val |= LSC_DCTL_ULSTCHNGREQ(5);
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

    reg_val |= LSC_DCTL_RUN_STOP;
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

    reg_val &= ~LSC_DCTL_INITU1ENA;
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

    reg_val &= ~LSC_DCTL_INITU2ENA;
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);

    usb_dev->is_config_done = 0;
    usb_dev->dev_speed = LSC_SPEED_UNKNOWN;

    usb_dev->is_enum_done = 0;

    lsc_iebm_buf_mgmt_init();
}

/****************************************************************************/
/**
 * Reset Interrupt handler.
 * This function performs initialization of controller during USB Reset.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is called when controller genrates USB Reset Event.
 *           <br>Refer sec 4.1.2 of Synopsis Programming Guide Version 3.30b
 *           for more information about Initialization on USB Reset Event.
 *****************************************************************************/
void lsc_usb_reset_int (struct lsc_usb_dev *usb_dev)
{
    LSC_INTR("lsc_usb_reset_int\r\n");

    uint32_t reg_val = 0;

    usb_dev->dev_state = LSC_STATE_DEFAULT;

    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCTL);
    reg_val &= ~LSC_DCTL_TSTCTRL_MASK;
    lsc_32_write((usb_dev->base_add + LSC_DCTL), reg_val);
    usb_dev->test_mode = 0;

    lsc_usb_stop_active_transfers(usb_dev);
    lsc_usb_clear_stall_all_ep(usb_dev);

    // Disable Eps
    // Except for control endpoint, we shall disable all endpoints.
    for (uint32_t i = 1; i < usb_dev->num_in_eps; i++) {
        lsc_usb_ep_disable(usb_dev, i, LSC_EP_DIR_IN);
    }

    for (uint32_t i = 1; i < usb_dev->num_out_eps; i++) {
        lsc_usb_ep_disable(usb_dev, i, LSC_EP_DIR_OUT);
    }

    for (int i = 0; i < (usb_dev->num_in_eps + usb_dev->num_out_eps); i++) {
        usb_dev->eps[i].ep_status = 0;
    }

    usb_dev->is_config_done = 0;
    usb_dev->is_enum_done = 0;

    /* Reset device address to zero */
    reg_val = lsc_32_read(usb_dev->base_add + LSC_DCFG);
    reg_val &= ~LSC_DCFG_DEVADDR_MASK;
    lsc_32_write((usb_dev->base_add + LSC_DCFG), reg_val);
}

/****************************************************************************/
/**
 * Handles Interrupts of Control Endpoints EP0 OUT and EP0 IN.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    event is a pointer to the Endpoint event occurred in core.
 *
 * @return   None.
 *
 * @note     This funtion is called when controller generates control
 *           endpoint related events.
 *****************************************************************************/
void lsc_usb_ep0_intr (struct lsc_usb_dev *usb_dev,
        const struct lsc_event_epevt *event)
{
    LSC_INTR("lsc_usb_ep0_intr\r\n");

//    LSC_INTR("ep0_intr: ep_event: %x\r\n", event->ep_event);

    switch (event->ep_event) {
        case LSC_DEPEVT_XFERCOMPLETE:
            lsc_usb_ep0_xfer_cmplt(usb_dev, event);
            break;

        case LSC_DEPEVT_XFERNOTREADY:
            lsc_usb_ep0_xfer_not_ready(usb_dev, event);
            break;

        case LSC_DEPEVT_XFERINPROGRESS:
        case LSC_DEPEVT_STREAMEVT:
        case LSC_DEPEVT_EPCMDCMPLT:
            break;

        default:
            LSC_INTR("Invalid Ep0 Events.!!\r\n");
            break;
    }
}

/****************************************************************************/
/**
 * Resume/Remote Wakeup Detected Event (WkUpEvt) handler.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is called when HOST initiates resume from
 *           U3/L2 or U3/L2L1 state and controller will generates
 *           wakeup event.<br>
 *           Refer Bit 4 (WKUPEVTEN) of Device Event Enable Register (DEVTEN)
 *           of sec 1.3.3 of Synopsis Programming Guide Version 3.30b
 *           for more information about Resume/Wakeup event.
 *****************************************************************************/
void lsc_usb_wakeup_int (struct lsc_usb_dev *usb_dev)
{
    LSC_INTR("lsc_usb_wakeup_int\r\n");

//    lsc_usb_set_link_state(usb_dev, LSC_LINK_STATE_CHANGE_RECOV);
}

/****************************************************************************/
/**
 * GPIO Interrupt handler.
 *
 * @param    context is a pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     This function is used to initiate device remote wakeup.
 *           On pressing GPIO, this ISR will perfrom setting usb link
 *           state to Recovery to acknowledge the resume/reset request.<br>
 *           Setting link state to recovery initiates remote wakeup request
 *           from device.<br>
 *           Refer Bit [8:5] (ULSTCHNGREQ) of Device Control Register (DCTL)
 *           of sec 1.3.3 of Synopsis Programming Guide Version 3.30b
 *           for more information about initiating Remote Wakeup request
 *           from device.
 *****************************************************************************/
void lsc_gpio_int_handler (void *context)
{
    printf("GPIO Interrupt\r\n");

    struct lsc_usb_dev *l_usb_dev;
    l_usb_dev = (struct lsc_usb_dev*)context;

    uint32_t gpio_int_sts = 0;

    // Read I2C Master Interrupt Source register
    //Ref: https://elixir.bootlin.com/linux/v6.6.7/source/drivers/usb/dwc3/gadget.c#L2352
//    gpio_int_sts = lsc_32_read(GPIO0_INST_BASE_ADDR + GPIO_INT_STATUS);
    printf("gpio_int_sts:%x\r\n", gpio_int_sts);

    // Write same value back to clear interrupts in interrupt source
//    lsc_32_write((GPIO0_INST_BASE_ADDR + GPIO_INT_STATUS), gpio_int_sts);

    //Device initiated remote wakeup
    if (l_usb_dev->wakeup_selfpowered
            & DEVICE_STATUS_REMOTE_WAKEUP_BUS_POWERED_10_VALUE) {
//        uint32_t retries = 0, reg_val = 0;
        lsc_usb_set_link_state(l_usb_dev, LSC_LINK_STATE_CHANGE_RECOV);

//        retries = 20000;
//
//        while (retries--) {
//            reg_val = lsc_32_read(l_usb_dev->base_add + LSC_DSTS);
//
//            /* in HS, means ON */
//            if (LSC_DSTS_USBLNKST(reg_val & LSC_DSTS_USBLNKST_MASK)
//                    == LSC_LINK_STATE_U0) {
//                printf("-----\r\n");
//                break;
//            }
//        }
    }
}

/** @} */
