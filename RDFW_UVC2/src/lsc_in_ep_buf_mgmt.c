// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file lsc_in_ep_buf_mgmt.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/
#include "lsc_in_ep_buf_mgmt.h"
#include "pic.h"

//#define DEBUG_LSC_IN_EP_BUF_MGMT

#ifdef DEBUG_LSC_IN_EP_BUF_MGMT
#define LSC_IN_EP_BUF_MGMT(msg, ...) sprintf(print_buf, msg, ##__VA_ARGS__); lsc_uart_tx(print_buf)
#else
#define LSC_IN_EP_BUF_MGMT(msg, ...)
#endif

/****************************************************************************/
/**
 * @brief
 * Configure/Re-Configure In endpoint buffer mangement IP Core.
 *
 * @return   LSC_SUCCESS else LSC_FAIL.
 *
 * @note     None.
 ****************************************************************************/
uint8_t lsc_iebm_buf_mgmt_init ( )
{
    uint32_t reg_val = 0, fw_buf = 0, fw_buf_depth = 0, hw_max_buf = 0,
            hw_buf_depth = 0;

    //Disable Interrupt
    lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_INT_EN_REG),
            ~LSC_IEBM_BUF_AVAIL_TO_FW_INT_EN_MASK);

    //Reset configured bit in CTRL register
    reg_val = lsc_32_read((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_CTRL_REG));
    lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_CTRL_REG),
            (reg_val & (~LSC_IEBM_IP_CNF_MASK)));

    //Load buffer configuration register
    lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_BUF_CNF_REG),
            ((LSC_IEBM_FW_TOTAL_BUF << LSC_IEBM_FW_TOTAL_BUF_OFST)
                    | LSC_IEBM_FW_SINGLE_BUF_DEPTH));

    reg_val = lsc_32_read(LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_HW_INFO_REG);

    hw_max_buf = LSC_IEBM_HW_MAX_BUF(reg_val);
    LSC_IN_EP_BUF_MGMT("hw_max_buf: %x\r\n", hw_max_buf);

    hw_buf_depth = LSC_IEBM_HW_SINGLE_BUF_MAX_DEPTH(reg_val);
    LSC_IN_EP_BUF_MGMT("hw_buf_depth: %x\r\n", hw_buf_depth);

    reg_val = lsc_32_read(LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_BUF_CNF_REG);
    LSC_IN_EP_BUF_MGMT("BUF_CNF_REG: %x\r\n", reg_val);

    fw_buf = LSC_IEBM_TOTAL_FW_BUF(reg_val);
    LSC_IN_EP_BUF_MGMT("fw_buf: %x\r\n", fw_buf);

    if (fw_buf > hw_max_buf) {
        LSC_IN_EP_BUF_MGMT("FW allocated more buffer than available in HW\r\n");
        return LSC_FAIL;
    }

    fw_buf_depth = reg_val & LSC_IEBM_FW_SINGLE_BUF_DEPTH_MASK;
    LSC_IN_EP_BUF_MGMT("fw_buf_depth: %x\r\n", fw_buf_depth);

    if (fw_buf_depth > hw_buf_depth) {
        LSC_IN_EP_BUF_MGMT("FW buffer depth is more HW buffer depth\r\n");
        return LSC_FAIL;
    }

    //Set flush buffer bit in CTRL register
    lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_CTRL_REG),
            LSC_IEBM_FLUSH_BUF_MASK);

    //Wait until flush buffer bit is cleared
    while (lsc_32_read(LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_CTRL_REG)
            & LSC_IEBM_FLUSH_BUF_MASK)
        ;

    //Enable Interrupt
    lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_INT_EN_REG),
            LSC_IEBM_BUF_AVAIL_TO_FW_INT_EN_MASK);

    return LSC_SUCCESS;
}

/****************************************************************************/
/**
 * @brief
 * This function registers In endpoint buffer mangement IP Core ISR.
 *
 * @param    usb_irq IRQ Number.
 * @param    isr Callback Function (ISR).
 * @param    context is a void pointer.
 *
 * @return   LSC_SUCCESS else LSC_FAIL
 *
 * @note     None.
 ****************************************************************************/
uint8_t lsc_iebm_buf_isr_register (uint32_t usb_irq, void (*isr) (void*),
        void *context)
{
    if (pic_isr_register(usb_irq, isr, context))
        return LSC_FAIL;

    return LSC_SUCCESS;
}

/****************************************************************************/
/**
 * @brief
 * LSC_IEBM Buffer Management Interrupt Handler.
 *
 * @param    context is a void pointer to the lsc_usb_dev instance.
 *
 * @return   None.
 *
 * @note     None.
 *****************************************************************************/
void lsc_iebm_buf_int_handler (void *context)
{

    LSC_IN_EP_BUF_MGMT("lsc_iebm_buf_int_handler\r\n");

    struct lsc_usb_dev *usb_dev = (struct lsc_usb_dev *)context;
    struct lsc_ep *ep;

    uint32_t reg_val = 0, sel_buf_sz = 0, buf_offset = 0, *ptr = NULL;
    uint8_t no_of_buf_to_be_proc_fw = 0, sel_buf_num = 0, ret = 0;
    uint8_t phy_ep_num = 0;

    phy_ep_num = lsc_physicalep(LSC_USB_IN_EP, LSC_EP_DIR_IN);
    ep = &usb_dev->eps[phy_ep_num];


    reg_val = lsc_32_read(
            LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_BUF_AVAIL_INFO_REG);
//    LSC_IN_EP_BUF_MGMT("BUF_AVAIL_INFO_REG: %x\r\n", reg_val);

    no_of_buf_to_be_proc_fw = reg_val
            & LSC_IEBM_NUM_BUF_TO_BE_PROCESS_BY_FW_MASK;

    LSC_IN_EP_BUF_MGMT("no_of_buf_to_be_proc_fw: %x\r\n",
            no_of_buf_to_be_proc_fw);

    while (no_of_buf_to_be_proc_fw) {
        reg_val = lsc_32_read(
                LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_SEL_BUF_INFO_FW_REG);

        sel_buf_num = reg_val & LSC_IEBM_SEL_BUF_NUM_MASK;
        LSC_IN_EP_BUF_MGMT("sel_buf_num: %x\r\n", sel_buf_num);

        sel_buf_sz = LSC_IEBM_SEL_BUF_SZ(reg_val);
        LSC_IN_EP_BUF_MGMT("sel_buf_sz: %x\r\n", sel_buf_sz);

        if (sel_buf_sz == 2) {
            reg_val = lsc_32_read(
                    LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_DEBUG_REG);
            LSC_IN_EP_BUF_MGMT("debug_reg: %x\r\n", reg_val);
        }

        buf_offset = LSC_IEBM_BUF_MEM_BASE + (sel_buf_num * HW_ALLOC_BUF_DEPTH);
        LSC_IN_EP_BUF_MGMT("buf_offset: %x\r\n", buf_offset);

        ret = lsc_usb_ep_buf_queue(usb_dev, LSC_USB_IN_EP, LSC_EP_DIR_IN,
                (uint8_t*)buf_offset, sel_buf_sz);

        if (ret) {
            // When the queue is full
            LSC_IN_EP_BUF_MGMT("Current buffer not store in Queue \r\n");
            break;
        } else {
            no_of_buf_to_be_proc_fw--;

            reg_val = lsc_32_read(
                    LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_XCHNGCTRL_REG);

            //Write fw processed one buffer to avail buffer to IP core
            reg_val |= LSC_IEBM_FW_PROCESSED_1_BUF_MASK;
            lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_XCHNGCTRL_REG),
                    reg_val);

            LSC_IN_EP_BUF_MGMT("fw processed one buffer\r\n");
        }
    }

    if (ep->handler != NULL) {
        ep->handler(usb_dev, LSC_USB_IN_EP, ep->max_ep_size);
    }

}

/**
 * @brief This function is used to handle user application specific tasks for a given USB device.
 *
 * @param usb_dev Pointer to the USB device structure.
 * @param usb_ep_num Endpoint number for the USB device.
 * @param dir Direction of data transfer (IN or OUT).
 */
void lsc_usb_user_application_spec (struct lsc_usb_dev *usb_dev,
        uint8_t usb_ep_num, uint8_t dir)
{

     LSC_IN_EP_BUF_MGMT("lsc_usb_iebm_user_class_sep\r\n");

    // Declare endpoint and physical endpoint number variables
    struct lsc_ep *ep;
    uint8_t phy_ep_num;

    // Get the physical endpoint number
    phy_ep_num = lsc_physicalep(usb_ep_num, dir);

    // Get the endpoint from the USB device
    ep = &usb_dev->eps[phy_ep_num];

    // Check if the direction is IN
    if (dir == LSC_EP_DIR_IN) {

        // Release the buffer
        uint32_t reg_val = 0;

        // Read the exchange control register
        reg_val = lsc_32_read(
                LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_XCHNGCTRL_REG);

        // Write Hand over bit to avail buffer to IP core
        reg_val |= LSC_IEBM_BUF_HO_EXT_FIFO_MSTR_MASK;

        // Write the updated value back to the exchange control register
        lsc_32_write((LSC_IEBM_BUF_MGMT_IP_BASE + LSC_IEBM_XCHNGCTRL_REG),
                reg_val);

        LSC_IN_EP_BUF_MGMT("Hand over one buf to IP\r\n");
    }
}

/** @} */
