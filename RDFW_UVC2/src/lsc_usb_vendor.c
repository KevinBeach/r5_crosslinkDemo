// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPELâ„¢
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/**
 *
 * @file lsc_usb_vendor.c
 * @addtogroup lscusb Overview
 * @{
 *
 *
 *
 *****************************************************************************/
#include "stdio.h"
#include "lsc_winsub.h"
#include "lsc_usb_dev.h"
#include "lsc_usb_vendor.h"

//#define DEBUG_LSC_USB_VENDOR

#ifdef DEBUG_LSC_USB_VENDOR
#define LSC_USB_VENDOR(msg, ...) sprintf(print_buf, msg, ##__VA_ARGS__); lsc_uart_tx(print_buf)
#else
#define LSC_USB_VENDOR(msg, ...)
#endif

uint8_t v_buf[VENDOR_REQ_MAX_SIZE] __attribute__ ((aligned(8)));
//uint8_t res_buf[256] __attribute__ ((aligned(8)))__attribute__((section(".myBufSection")));

/*****************************************************************************/
/**
 * This function handles usb device vendor specific requests.
 *
 * @param    usb_dev is a void pointer.
 * @param    setup_pkt is a pointer to the data structure containing the
 *           setup request.
 *
 * @return   None.
 *
 * @note     None.
 ******************************************************************************/
void lsc_usb_vendor_req (struct lsc_usb_dev *usb_dev, setup_pkt *setup_pkt)
{

    LSC_USB_VENDOR("lsc_usb_vendor_req\r\n");

    uint8_t dir = setup_pkt->bRequestType & LSC_USB_DIR_IN;

    uint32_t size = 0;

    if (usb_dev->ep0_state == LSC_EP0_SETUP_PHASE) {

        LSC_USB_VENDOR("Setup Pkt: %x %x %2x %2x %2x\r\n",
                setup_pkt->bRequestType, setup_pkt->bRequest, setup_pkt->wValue,
                setup_pkt->wIndex, setup_pkt->wLength);
    }

    if (dir) {
        //Vendor IN Request
        LSC_USB_VENDOR("Vendor IN Req\r\n");

        switch (setup_pkt->bRequest) {
            case WINUSB_REQ:
                LSC_USB_VENDOR("WinUSB Req\r\n")
                ;

                switch (setup_pkt->wIndex) {
                    case MS_OS_2_0_DESC_SET_REQUEST:
                        LSC_USB_VENDOR("MS Os 2.0 Desc Req\r\n\n")
                        ;

                        lsc_usb_ep0_send(usb_dev, descp_set,
                                setup_pkt->wLength);
                        break;

                    default:
                        lsc_usb_ep0_stall_restart(usb_dev);
                        break;
                }
                break;

            case LSC_VENDOR_BREQ:
                LSC_USB_VENDOR("LSC Vendor IN\r\n\n")
                ;

                for (uint32_t i = 0; i < 10/*setup_pkt->wLength*/; i++)
                    v_buf[i] = i;

                //vendor brequest 1 supports a maximum 10 bytes.
                size = (setup_pkt->wLength < 10) ? setup_pkt->wLength : 10;
                lsc_usb_ep0_send(usb_dev, v_buf, size);

                break;

            default:
                lsc_usb_ep0_stall_restart(usb_dev);
                break;
        }
    } else {
        //Vendor OUT Request
        LSC_USB_VENDOR("Vendor OUT Req\r\n");

        switch (setup_pkt->bRequest) {
            case LSC_VENDOR_BREQ:
                LSC_USB_VENDOR("LSC Vendor OUT\r\n\n")
                ;

                switch (usb_dev->ep0_state) {
                    case LSC_EP0_SETUP_PHASE:
                        //vendor brequest 1 supports a maximum 10 bytes.
                        size = (setup_pkt->wLength < 10) ?
                                setup_pkt->wLength : 10;

                        lsc_usb_ep0_rcv(usb_dev, /*v_buf*/res_buf,
                                size);
                        break;

                    case LSC_EP0_DATA_PHASE:
                    	memcpy(v_buf, res_buf, setup_pkt->wLength);

                        for (int i = 0; i < setup_pkt->wLength; i++) {
                            LSC_USB_VENDOR("%d, ", v_buf[i]);
                        }
                        LSC_USB_VENDOR("\r\n")
                        ;
                        break;

                    default:
                        lsc_usb_ep0_stall_restart(usb_dev);
                        break;
                }
                break;

            default:
                lsc_usb_ep0_stall_restart(usb_dev);
                break;
        }
    }
}

/** @} */
