// >>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------------
// Copyright (c) 2019-2024 by Lattice Semiconductor Corporation
// ALL RIGHTS RESERVED
// --------------------------------------------------------------------------
//
// IMPORTANT: THIS FILE IS USED BY OR GENERATED BY the LATTICE PROPEL™
// DEVELOPMENT SUITE, WHICH INCLUDES PROPEL BUILDER AND PROPEL SDK.
//
// Lattice grants permission to use this code pursuant to the
// terms of the Lattice Propel License Agreement.
//
// DISCLAIMER:
//
//  LATTICE MAKES NO WARRANTIES ON THIS FILE OR ITS CONTENTS, WHETHER
//  EXPRESSED, IMPLIED, STATUTORY, OR IN ANY PROVISION OF THE LATTICE
//  PROPEL LICENSE AGREEMENT OR COMMUNICATION WITH LICENSEE, AND LATTICE
//  SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF MERCHANTABILITY OR
//  FITNESS FOR A PARTICULAR PURPOSE.  LATTICE DOES NOT WARRANT THAT THE
//  FUNCTIONS CONTAINED HEREIN WILL MEET LICENSEE'S REQUIREMENTS, OR THAT
//  LICENSEE'S OPERATION OF ANY DEVICE, SOFTWARE OR SYSTEM USING THIS FILE
//  OR ITS CONTENTS WILL BE UNINTERRUPTED OR ERROR FREE, OR THAT DEFECTS
//  HEREIN WILL BE CORRECTED.  LICENSEE ASSUMES RESPONSIBILITY FOR
//  SELECTION OF MATERIALS TO ACHIEVE ITS INTENDED RESULTS, AND FOR THE
//  PROPER INSTALLATION, USE, AND RESULTS OBTAINED THEREFROM.  LICENSEE
//  ASSUMES THE ENTIRE RISK OF THE FILE AND ITS CONTENTS PROVING DEFECTIVE
//  OR FAILING TO PERFORM PROPERLY AND IN SUCH EVENT, LICENSEE SHALL
//  ASSUME THE ENTIRE COST AND RISK OF ANY REPAIR, SERVICE, CORRECTION, OR
//  ANY OTHER LIABILITIES OR DAMAGES CAUSED BY OR ASSOCIATED WITH THE
//  SOFTWARE.  IN NO EVENT SHALL LATTICE BE LIABLE TO ANY PARTY FOR DIRECT,
//  INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST
//  PROFITS, ARISING OUT OF THE USE OF THIS FILE OR ITS CONTENTS, EVEN IF
//  LATTICE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. LATTICE'S
//  SOLE LIABILITY, AND LICENSEE'S SOLE REMEDY, IS SET FORTH ABOVE.
//  LATTICE DOES NOT WARRANT OR REPRESENT THAT THIS FILE, ITS CONTENTS OR
//  USE THEREOF DOES NOT INFRINGE ON THIRD PARTIES' INTELLECTUAL PROPERTY
//  RIGHTS, INCLUDING ANY PATENT. IT IS THE USER'S RESPONSIBILITY TO VERIFY
//  THE USER SOFTWARE DESIGN FOR CONSISTENCY AND FUNCTIONALITY THROUGH THE
//  USE OF FORMAL SOFTWARE VALIDATION METHODS.
// --------------------------------------------------------------------------

/****************************************************************************/
/**
 *
 * @file main.c
 *
 * This file implements the USB Device Controller.
 *
 *
 *****************************************************************************/

#include <stdio.h>
#include "uart.h"
#include "utils.h"
#include "lsc_usb_dev.h"
#include "pic.h"
#include "gpio_regs.h"
#include "gpio.h"
#include "lsc_in_ep_buf_mgmt.h"
#include "i2c_master.h"
#include "i2c_master_regs.h"
#include "uvc/camera_initialization.h"
#include "uvc/lsc_ccm_reg.h"
#include "sys_platform.h"
#include "cli.h"


#define LSC_USB_DEV_BASE_ADD                  AHBL_TO_LMMI_BRIDGE_BASE_ADDR//0x20000
#define USB20SR_PIC_START_ADDR                CPU0_INST_PICTIMER_START_ADDR     /**< USB20SR PIC Start Address. */
#define USB20SR_IRQ                           1                                 /**< USB20SR Control Port IRQ. */

struct uart_instance uart_core_uart;
struct lsc_usb_dev usb_dev;
struct lsc_usb_dev_dm usb_dev_dm __attribute__((section(".myBufSection")));
struct gpio_instance gpio_0;
struct i2cm_instance i2c_master_core;

uint8_t bulk_data_buf[LSC_BULK_MAX_BUFR_SIZE] __attribute__ ((aligned(4))) /*__attribute__((section(".myBufSection")))*/
= {0};


uint8_t print_buf[256];

extern volatile uint8_t straming_en;
extern uint32_t x_cmplt, x_nready, ep_send;

uint8_t isr_register (uint32_t pic_start_add, uint32_t usb_irq,
        void (*isr) (void*), void *context)
{
//    sprintf(print_buf, "isr_register\r\n");
//    lsc_uart_tx(print_buf);

    pic_init(pic_start_add);

    if (pic_isr_register(usb_irq, isr, context)) {
//        sprintf(print_buf, "ISR registration failed.\r\n");
//        lsc_uart_tx(print_buf);

        return LSC_FAIL;
    }

    return LSC_SUCCESS;
}

int main (void)
{
    static uint8_t idx = 0;
    uint8_t status, tx_config_buf[3];
    uint32_t hw_ver = 0;
    uint32_t ccm_config = 0, ccm_mtx_coe = 0, ccm_mtx_mgg = 0, ccm_mtx_mbb= 0, ccm_mtx_mrr=0;
    uint32_t ccm = 0;
    uint32_t reg_val = 0, sel_buf_sz = 0, buf_offset = 0;
    uint8_t no_of_buf_to_be_proc_fw = 0, buf_avail_for_fw_proc = 0, sel_buf_num = 0;
    uint16_t cam_chip_id=0;
    unsigned char tx_buf[2]={0x00,0x00},rx_bufr[4];
    unsigned char c; //krb addition for UART RX

    uart_init(&uart_core_uart, UART0_INST_BASE_ADDR, CPU_FREQUENCY,
            UART0_INST_BAUD_RATE, 1, 8);

    uart_core_uart.blockingRx = 0;

#ifdef LSCC_STDIO_UART_APB
    extern struct uart_instance *g_stdio_uart;
    g_stdio_uart = &uart_core_uart;
#endif

    i2c_master_init (
             &i2c_master_core,
             LSC_I2CC_INST_BASE_ADDR
             );

    mtime_init();

    i2c_master_repeated_start (
    		&i2c_master_core,
    		TRGT_SLV_ADDR,
			0x2,
			tx_buf,
			0x02,
			rx_bufr);

    cam_chip_id = (rx_bufr[0] << 8) | (rx_bufr[1]);

    printf ("Device Chip-ID is 0x%x \r\n", cam_chip_id );

    // Initializing Device Controller.
    // Refer sec 4.1 of Synopsis Programming Guide Version 3.30b
    // for Initializing Registers.
    status = lsc_usb_init(&usb_dev, LSC_USB_DEV_BASE_ADD);
    if (status != LSC_SUCCESS)
        return LSC_FAIL;

    // Register USB ISR into Interrupt Controller
    status = isr_register(USB20SR_PIC_START_ADDR, USB20SR_IRQ,
            lsc_usb_int_handler, &usb_dev);
    if (status != LSC_SUCCESS)
        return LSC_FAIL;

    // Enable Device Event Interrupts into Device Event Enable Register.
    // Refer sec 1.3.3 of Synopsis Programming Guide Version 3.30b
    // for Device Event Enable Register (DEVTEN).
    lsc_usb_enable_int(&usb_dev, LSC_DEVTEN_MASK);

    //Unknown register information is from lattice shared c file
    //added for usb3.0
    lsc_32_write(LSC_USB_DEV_BASE_ADD | 0x000100AC, 0x020E4500); // 402b

    // Setting endpoint handler and presetting trb for respective endpoint.
    // Here we are setting up transfers before the host attempts to move data on a EP
    // i.e.preset transfer. Hence we can safely ignore/disable transfer not ready in this case.
    // Refer sec 4.2.4 Transfer Setup Recommendations of Synopsis Programming Guide Version 3.30b.

    // Here we are setting handler for IN endpoint 1
    // lsc_bulk_in_handler will get called when we get transfer complete interrupt for this endpoint.
    lsc_set_ep_handler(&usb_dev, LSC_USB_IN_EP, LSC_EP_DIR_IN,
            lsc_bulk_in_handler);

    configure_uvc_device();

    // Assigning Class Specific requet handling function to perform class specific task.
    usb_dev.usb_class_req_handler = lsc_usb_class_req;

    status = lsc_iebm_buf_mgmt_init();
    if(status == LSC_FAIL)
        return 0;

    //Setting vendor request handler here to perform vendor specific task.
    usb_dev.usb_vendor_req_handler = lsc_usb_vendor_req;
    //Setting user class specific handler here.
    usb_dev.lsc_usr_app_handler = lsc_usb_user_application_spec;


    // Register Buffer Mgmt ISR
    status = pic_isr_register(LSC_IEBM_BUF_MGMT_IRQ, lsc_iebm_buf_int_handler, &usb_dev);
    if (status != LSC_SUCCESS)
    {
        sprintf(print_buf, "IEBM ISR Fail.");
        lsc_uart_tx(print_buf);

        return LSC_FAIL;
    }


    // Start USB Controller by setting Bit:31 (RUN_STOP)
    // into DCTL register.
    // Refer sec 1.3.2 of Synopsis Programming Guide Version 3.30b
    // for Device Control Register (DCTL).
    lsc_usb_start(&usb_dev);

    status = 0;

    printf("\n####################### ALLAN TEST 2 #################");
    while (1){

    	//krb addition to poll for UART input - testing UART
    	if (uart_getc(&uart_core_uart, &c) == 0) {
    	    cli_rx_char(c);
    	}
    	// end of krb input

        if(usb_dev.is_enum_done && !status){

            if ( cam_chip_id == IMX219_SENSOR_ID ) {

                mode_default_register_init();

                if(usb_dev.dev_speed == LSC_SPEED_SUPER)
                    usb3_cam_pll_setting();
                else
                    usb2_cam_pll_setting();

                set_resolution();

            }

            while(!straming_en);

            if(usb_dev.is_enum_done){

                // Let's enable the camera sensor if we've read correct chip ID.
                // If not, we need to enable the YUY2 solid color test pattern.

                if ( cam_chip_id == IMX219_SENSOR_ID ) {

                    printf ("Camera found.\r\n");


                    //Test pattern enable GPIO
                    // 0x1 - yuy2_tp_en (YUV422 test pattern)
                    // lsc_8_write((TP_EN_GPIO_INST_BASE_ADDR + 0x4), 0x1);

                    enable_camera();


                } else {

                    printf ("Camera not found.\r\n");

                    // Enable selected test pattern based on the TP_EN_GPIO
                    lsc_8_write((TP_EN_GPIO_INST_BASE_ADDR + 0x4), 0x1);

                }

                //Initialize Lattice Color Correction Matrix
                lsc_ccm_init(AHBL_TO_AXI_LITE_BRIDGE_BASE_ADDR);

                status = 1;
            }
        }

        //When enumeration isn’t complete and the status bit is 1, we reset it to 0. After enumeration,
        //we set the camera settings once, as explained in the following logic
        if(!usb_dev.is_enum_done && status){
            status = 0;
            straming_en = 0;
        }



    }
        ;

    return LSC_SUCCESS;
}

/****************************************************************************/
/**
 * This function is Bulk Out Endpoint handler/Callback called by driver when
 * data is received.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    ep_num is USB endpoint number.
 * @param    requested_bytes is number of bytes requested for reception.
 *
 * @return   None
 *
 * @note     None.
 *
 *****************************************************************************/
void lsc_bulk_out_handler (struct lsc_usb_dev *usb_dev, uint8_t ep_num,
        uint32_t requested_bytes)
{

//      sprintf(print_buf, "Boh\r\n");
//        lsc_uart_tx(print_buf);

    uint8_t phy_ep_num = 0, ret = 0;
    uint8_t *buf = NULL;
    uint32_t size = 0;
    struct lsc_ep *ep = NULL;

    phy_ep_num = lsc_physicalep(ep_num, LSC_EP_DIR_OUT);
    ep = &usb_dev->eps[phy_ep_num];

#ifdef LOOPBACK

    //When we need to perform loopback then we should initiate only BULK OUT trb first during set configuration
    //and then BULK IN trb will get initiated after OUT transfer is completed.

    if (!usb_dev->is_enum_done) {

        //first time buffer details filled in queue here
        lsc_usb_ep_buf_queue(usb_dev, ep_num, LSC_EP_DIR_OUT, bulk_data_buf,
                sizeof(bulk_data_buf));
    }

    if (ep->remain_bytes) {

        ret = lsc_usb_ep_buf_rcv(usb_dev, ep_num, ep->buffer_ptr,
                ep->remain_bytes);

    } else {

        if (!ep->ep_buf_i[ep->ep_buf_i_dequeue].no_of_event) {

            //clear due to dequeue buffer now clear and after that new dequeue buffer event we received so new dequeue buffer bytes_txfered details store
            ep->bytes_txfered = 0;

            //clear the dequeue buffer details for new buffer details store at that place
            ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_size = 0;
            ep->ep_buf_i[ep->ep_buf_i_dequeue].buf_ptr = 0;

            // Increment the dequeue index
            ep->ep_buf_i_dequeue++;

            // If the dequeue index reaches the maximum, reset it to zero
            if (ep->ep_buf_i_dequeue == NO_OF_BUF) {
                ep->ep_buf_i_dequeue = 0;
            }

            // We enqueue a new buffer for BULK OUT
            lsc_usb_ep_buf_queue(usb_dev, ep_num, LSC_EP_DIR_OUT, bulk_data_buf,
                    sizeof(bulk_data_buf));
        }

        if (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event) {

            buf = ep->ep_buf_i[ep->ep_buf_i_rd].buf_ptr;
            size = ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;

            // This should be updated here becuse In lsc_usb_ep_buf_rcv functions it may be go in next front if more trb available
            ep->ep_buf_i_rd++;

            if (ep->ep_buf_i_rd == NO_OF_BUF) {
                ep->ep_buf_i_rd = 0;
            }

            ret = lsc_usb_ep_buf_rcv(usb_dev, ep_num, buf, size);
            if (ret) {
//                  printf("lsc_usb_ep_buf_rcv return an error\r\n");

                // If an error occurs, we decrease the 'ep_buf_i_rd' index because something went wrong in the lsc_usb_ep_buf_rcv.
                // Reasons why the 'lsc_usb_ep_buf_rcv' function might return an error:
                // 1) Incorrect direction
                // 2) The TRB to be used is busy
                // 3) Command status error
                if (ep->ep_buf_i_rd) {
                    ep->ep_buf_i_rd--;
                } else {
                    ep->ep_buf_i_rd = NO_OF_BUF - 1;
                }
                return;
            }

        } else {
            //In this condition, your code is executed, which means that there are no buffers in the queue for reading (transfer to TRB)
//              printf("no more buf in ep_buf_i[ep->ep_buf_i_rd]\r\n");
        }
    }

#else

    // The following 'if' condition is used when a new buffer is being loaded into a new TRB (Transfer Request Block).
    // If there are still some remaining bytes in the buffer that haven't been loaded into the previous TRB due to its full capacity,
    // this condition handles that scenario.
    // It also provides protection against multiple invocations of the handler function from outside,
    // ensuring that the buffer details are correctly filled into the next TRB.

    if (ep->remain_bytes) {

//          printf("remain_bytes %d\r\n",ep->remain_bytes);
        lsc_usb_ep_buf_rcv(usb_dev, ep_num, ep->buffer_ptr, ep->remain_bytes);

    } else {

        // This below if condition is for testing purposes, specifically for 'OUT Direction' streaming tests of a generic nature.
        // For any user class specific use, this 'below if' condition should be removed or commented out.
        if (!(ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event)) {
            lsc_usb_ep_buf_queue(usb_dev, ep_num, LSC_EP_DIR_OUT, bulk_data_buf,
                    sizeof(bulk_data_buf));
        }

        //This below if condition is for generic flow so don't removed it in any user class.
        if (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event) {

            buf = ep->ep_buf_i[ep->ep_buf_i_rd].buf_ptr;
            size = ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;

            // This should be updated here becuse In lsc_usb_ep_buf_rcv functions it may be go in next front if more trb available
            ep->ep_buf_i_rd++;

            if (ep->ep_buf_i_rd == NO_OF_BUF) {
                ep->ep_buf_i_rd = 0;
            }

            ret = lsc_usb_ep_buf_rcv(usb_dev, ep_num, buf, size);
            if (ret) {
//                  printf("lsc_usb_ep_buf_rcv return an error\r\n");

                // If an error occurs, we decrease the 'ep_buf_i_rd' index because something went wrong in the lsc_usb_ep_buf_rcv.
                // Reasons why the 'lsc_usb_ep_buf_rcv' function might return an error:
                // 1) Incorrect direction
                // 2) The TRB to be used is busy
                // 3) Command status error

                if (ep->ep_buf_i_rd) {
                    ep->ep_buf_i_rd--;
                } else {
                    ep->ep_buf_i_rd = NO_OF_BUF - 1;
                }

            }

        } else {
            //In this condition, your code is executed, which means that there are no buffers in the queue for reading (transfer to TRB)
//              printf("no more buf in ep_buf_i[ep->ep_buf_i_rd]\r\n");
        }

    }

#endif

}

/****************************************************************************/
/**
 * This function is Bulk In Endpoint handler/Callback called by driver when
 * data is sent.
 *
 * @param    usb_dev is a pointer to the lsc_usb_dev instance.
 * @param    ep_num is USB endpoint number.
 * @param    requested_bytes is number of bytes requested to send.
 *
 * @return   None
 *
 * @note     None.
 *
 *****************************************************************************/
void lsc_bulk_in_handler (struct lsc_usb_dev *usb_dev, uint8_t ep_num,
        uint32_t requested_bytes)
{

//  sprintf(print_buf, "Bih\r\n");
//  lsc_uart_tx(print_buf);

    uint8_t phy_ep_num = 0, ret = 0;
    uint8_t *buf = NULL;
    uint32_t size = 0;
    struct lsc_ep *ep = NULL;

    phy_ep_num = lsc_physicalep(ep_num, LSC_EP_DIR_IN);
    ep = &usb_dev->eps[phy_ep_num];

#ifdef LOOPBACK

    //If enumeration is done and we received Bulk OUT completion event then we should initiate the Bulk IN trb.

    if (usb_dev->is_enum_done) {

        if (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event) {

            buf = ep->ep_buf_i[ep->ep_buf_i_rd].buf_ptr;
            size = ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;

            // This should be updated here becuse In lsc_usb_ep_buf_send functions it may be go in next front if more trb available
            ep->ep_buf_i_rd++;

            if (ep->ep_buf_i_rd == NO_OF_BUF) {
                ep->ep_buf_i_rd = 0;
            }

            ret = lsc_usb_ep_buf_send(usb_dev, ep_num, buf, size);
            if (ret) {
//                  printf("lsc_usb_ep_buf_send return an error\r\n");

                // If an error occurs, we decrease the 'ep_buf_i_rd' index because something went wrong in the lsc_usb_ep_buf_send.
                // Reasons why the 'lsc_usb_ep_buf_send' function might return an error:
                // 1) Incorrect direction
                // 2) The TRB to be used is busy
                // 3) Command status error

                if (ep->ep_buf_i_rd) {
                    ep->ep_buf_i_rd--;
                } else {
                    ep->ep_buf_i_rd = NO_OF_BUF - 1;
                }

                return;
            }

        } else {
            //In this condition, your code is executed, which means that there are no buffers in the queue for reading (transfer to TRB)
//              printf("no more buf in ep_buf_i[ep->ep_buf_i_rd]\r\n");
        }

    }

#else

    //This is for the if out sider function call multiple times handler so below condition take care of it
    if (ep->remain_bytes) {

//          printf("remain_bytes %d\r\n",ep->remain_bytes);
        lsc_usb_ep_buf_send(usb_dev, ep_num, ep->buffer_ptr, ep->remain_bytes);

    } else {

#ifndef LSC_IEBM
        // This below if condition is for testing purposes, specifically for 'IN Direction' streaming tests of a generic nature.
        // For any user class specific use, this 'below if' condition should be removed or commented out.
//        if (!(ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event)) {
//            lsc_usb_ep_buf_queue(usb_dev, ep_num, LSC_EP_DIR_IN, bulk_data_buf,
//                    sizeof(bulk_data_buf));
//        }
#endif

        //This below if condition is for generic flow so don't removed it in any user class.
        if (ep->ep_buf_i[ep->ep_buf_i_rd].no_of_event) {

            buf = ep->ep_buf_i[ep->ep_buf_i_rd].buf_ptr;
            size = ep->ep_buf_i[ep->ep_buf_i_rd].buf_size;

            // This should be updated here becuse In send functions it may be go in next front if more trb available
            ep->ep_buf_i_rd++;

            if (ep->ep_buf_i_rd == NO_OF_BUF) {
                ep->ep_buf_i_rd = 0;
            }

            ret = lsc_usb_ep_buf_send(usb_dev, ep_num, buf, size);
            if (ret) {

//                  printf("lsc_usb_ep_buf_send return an error\r\n");

                // If an error occurs, we decrease the 'ep_buf_i_rd' index because something went wrong in the lsc_usb_ep_buf_send.
                // Reasons why the 'lsc_usb_ep_buf_send' function might return an error:
                // 1) Incorrect direction
                // 2) The TRB to be used is busy
                // 3) Command status error

                if (ep->ep_buf_i_rd) {
                    ep->ep_buf_i_rd--;
                } else {
                    ep->ep_buf_i_rd = NO_OF_BUF - 1;
                }
            }

        } else {
            //In this condition, your code is executed, which means that there are no buffers in the queue for reading (transfer to TRB)
//              printf("no more buf in ep_buf_i[ep->ep_buf_i_rd]\r\n");
        }

    }

#endif
}
